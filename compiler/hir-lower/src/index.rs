use diagnostics::{FileDiagnostic, FilePath, Span};
use hir::{AstMap, Path};
use rustc_hash::{FxHashMap, FxHashSet};
use syntax::{
	ast,
	ast::{ImportTree, ItemKind, Name},
	AstElement,
};
use text::Text;
use tracing::{span, Level};
use verde::{Id, Tracked};

use crate::Module;

/// A declaration that is bound to a name.
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Declaration {
	Item(ast::Item), // `ItemKind::ImportTree` not allowed.
	Import {
		/// If we should start searching from the root scope, not module scope.
		root: bool,
		path: Id<Path>, // Not an `AbsolutePath` because we don't know where it actually came from.
	},
}

/// A map from a module to the items within it.
#[derive(Debug)]
pub struct ModuleMap {
	decls: FxHashMap<Text, Declaration>,
	file: FilePath,
}

impl ModuleMap {
	pub fn new(file: FilePath) -> Self {
		Self {
			decls: FxHashMap::default(),
			file,
		}
	}

	pub fn file(&self) -> FilePath { self.file }

	pub fn add_decl(&mut self, name: Text, decl: Declaration) { self.decls.insert(name, decl); }

	pub fn get_decl(&self, name: Text) -> &Declaration { &self.decls[&name] }
}

/// An index for the public interface of a module - visible to modules outside itself.
pub type PublicIndex = InnerIndex<true>;
/// An index for the private interface of a module - visible only to modules inside itself (and itself).
pub type PrivateIndex = InnerIndex<false>;

#[derive(Tracked, Debug, Eq, PartialEq)]
pub struct InnerIndex<const PUBLIC: bool> {
	#[id]
	path: FilePath,
	/// The names that exist in this module. Use the `ModuleMap` to figure out what they actually point to.
	names: FxHashSet<Text>,
}

impl<const PUBLIC: bool> InnerIndex<PUBLIC> {
	pub fn new(path: FilePath) -> Self {
		Self {
			path,
			names: FxHashSet::default(),
		}
	}
}

pub struct Index {
	pub public: Id<PublicIndex>,
	pub private: Id<PrivateIndex>,
	pub map: ModuleMap,
}

/// Generate an index for the given module. This should be rerun on every reparse, which is why it doesn't plug into the
/// incremental system.
///
/// `diags` is cleared and filled with any diagnostics generated by the index.
pub fn generate_indices(module: &Module, diags: &mut Vec<FileDiagnostic>) -> Index {
	let s = span!(Level::TRACE, "generate index", path = %module.file.path().display());
	let _e = s.enter();

	diags.clear();
	let mut public = InnerIndex::new(module.file);
	let mut private = InnerIndex::new(module.file);
	let mut map = ModuleMap::new(module.file);
	let mut span_map = FxHashMap::default();

	let mut insert = |name: Option<Name>, decl: Declaration, is_public: bool| {
		if let Some(name) = name {
			if let Some(text) = name.text() {
				let old = span_map.insert(text, name.span());
				map.add_decl(text, decl);
				private.names.insert(text);
				if is_public {
					public.names.insert(text);
				}

				if let Some(old) = old {
					diags.push(
						name.span()
							.error("duplicate definition")
							.label(old.label("old definition here"))
							.label(name.span().label("redefined here")),
					);
				}
			}
		}
	};

	for item in module.ast.items() {
		let public = item.visibility().is_some();
		let name = match item.item_kind() {
			Some(ItemKind::Fn(f)) => f.name(),
			Some(ItemKind::Struct(s)) => s.name(),
			Some(ItemKind::Enum(e)) => e.name(),
			Some(ItemKind::TypeAlias(t)) => t.name(),
			Some(ItemKind::Static(s)) => s.name(),
			Some(ItemKind::Import(i)) => {
				fn visit_tree(
					public: bool, tree: Option<ImportTree>, insert: &mut impl FnMut(Option<Name>, Declaration, bool),
				) {
					match tree {
						Some(ImportTree::ListImport(i)) => {
							if let Some(list) = i.import_tree_list() {
								list.import_trees().for_each(|x| visit_tree(public, Some(x), insert));
							}
						},
						Some(ImportTree::RenameImport(i)) => {
							insert(
								i.rename()
									.and_then(|r| r.name())
									.or_else(|| i.path().and_then(|x| x.segment().and_then(|x| x.name()))),
								public,
							);
						},
						None => {},
					}
				}
				visit_tree(public, i.import_tree(), &mut insert);
				continue;
			},
			None => continue,
		};

		insert(name, Declaration::Item(item), public);
	}

	Index {
		public: db.set_input(public),
		private: db.set_input(private),
		map,
	}
}
