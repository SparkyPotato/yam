// This file is generated by build.rs
// Do not edit

use crate::generated::*;

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Semi(SyntaxToken);
impl std::fmt::Debug for Semi {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Semi {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Semi }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct At(SyntaxToken);
impl std::fmt::Debug for At {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for At {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::At }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FnKw(SyntaxToken);
impl std::fmt::Debug for FnKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for FnKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LParen(SyntaxToken);
impl std::fmt::Debug for LParen {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for LParen {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LParen }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Comma(SyntaxToken);
impl std::fmt::Debug for Comma {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Comma {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Comma }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RParen(SyntaxToken);
impl std::fmt::Debug for RParen {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for RParen {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RParen }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Colon(SyntaxToken);
impl std::fmt::Debug for Colon {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Colon {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Colon }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Arrow(SyntaxToken);
impl std::fmt::Debug for Arrow {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Arrow {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Arrow }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PubKw(SyntaxToken);
impl std::fmt::Debug for PubKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for PubKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PubKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ExternKw(SyntaxToken);
impl std::fmt::Debug for ExternKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ExternKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ExternKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct StringLit(SyntaxToken);
impl std::fmt::Debug for StringLit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for StringLit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::StringLit }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct StructKw(SyntaxToken);
impl std::fmt::Debug for StructKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for StructKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::StructKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LBrace(SyntaxToken);
impl std::fmt::Debug for LBrace {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for LBrace {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LBrace }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RBrace(SyntaxToken);
impl std::fmt::Debug for RBrace {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for RBrace {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RBrace }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct EnumKw(SyntaxToken);
impl std::fmt::Debug for EnumKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for EnumKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::EnumKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TypeKw(SyntaxToken);
impl std::fmt::Debug for TypeKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for TypeKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TypeKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Eq(SyntaxToken);
impl std::fmt::Debug for Eq {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Eq {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Eq }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct StaticKw(SyntaxToken);
impl std::fmt::Debug for StaticKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for StaticKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::StaticKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportKw(SyntaxToken);
impl std::fmt::Debug for ImportKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ImportKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Dot(SyntaxToken);
impl std::fmt::Debug for Dot {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Dot {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Dot }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Star(SyntaxToken);
impl std::fmt::Debug for Star {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Star {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Star }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct AsKw(SyntaxToken);
impl std::fmt::Debug for AsKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for AsKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::AsKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LBracket(SyntaxToken);
impl std::fmt::Debug for LBracket {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for LBracket {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LBracket }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RBracket(SyntaxToken);
impl std::fmt::Debug for RBracket {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for RBracket {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RBracket }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Underscore(SyntaxToken);
impl std::fmt::Debug for Underscore {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Underscore {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Underscore }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ConstKw(SyntaxToken);
impl std::fmt::Debug for ConstKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ConstKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ConstKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MutKw(SyntaxToken);
impl std::fmt::Debug for MutKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for MutKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MutKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ContinueKw(SyntaxToken);
impl std::fmt::Debug for ContinueKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ContinueKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ContinueKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LetKw(SyntaxToken);
impl std::fmt::Debug for LetKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for LetKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LetKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Operator(SyntaxToken);
impl std::fmt::Debug for Operator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Operator {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Operator }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BreakKw(SyntaxToken);
impl std::fmt::Debug for BreakKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for BreakKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BreakKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ForKw(SyntaxToken);
impl std::fmt::Debug for ForKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ForKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ForKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InKw(SyntaxToken);
impl std::fmt::Debug for InKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for InKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IfKw(SyntaxToken);
impl std::fmt::Debug for IfKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for IfKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IfKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ElseKw(SyntaxToken);
impl std::fmt::Debug for ElseKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ElseKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ElseKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BoolLit(SyntaxToken);
impl std::fmt::Debug for BoolLit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for BoolLit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BoolLit }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CharLit(SyntaxToken);
impl std::fmt::Debug for CharLit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for CharLit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CharLit }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FloatLit(SyntaxToken);
impl std::fmt::Debug for FloatLit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for FloatLit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FloatLit }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IntLit(SyntaxToken);
impl std::fmt::Debug for IntLit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for IntLit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IntLit }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LoopKw(SyntaxToken);
impl std::fmt::Debug for LoopKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for LoopKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LoopKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct WhileKw(SyntaxToken);
impl std::fmt::Debug for WhileKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for WhileKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::WhileKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchKw(SyntaxToken);
impl std::fmt::Debug for MatchKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for MatchKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FatArrow(SyntaxToken);
impl std::fmt::Debug for FatArrow {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for FatArrow {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FatArrow }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ReturnKw(SyntaxToken);
impl std::fmt::Debug for ReturnKw {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for ReturnKw {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ReturnKw }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Ident(SyntaxToken);
impl std::fmt::Debug for Ident {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstToken for Ident {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Ident }

	fn cast(tok: SyntaxToken) -> Option<Self> {
		if Self::can_cast(tok.kind()) {
			Some(Self(tok))
		} else {
			None
		}
	}
}
