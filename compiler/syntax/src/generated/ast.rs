
#![allow(clippy::all)]
// This file is generated by build.rs
// Do not edit

use diagnostics::FileSpan;

use crate::{generated::*, token::*, *};

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct File(SyntaxNode);
impl std::fmt::Debug for File {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for File {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for File {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::File }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl File {
	pub fn items(&self) -> impl Iterator<Item = Item> + '_ { node_children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Item(SyntaxNode);
impl std::fmt::Debug for Item {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Item {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Item {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Item }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Item {
	pub fn attributes(&self) -> impl Iterator<Item = Attribute> + '_ { node_children(&self.0) }

	pub fn visibility(&self) -> Option<Visibility> { node_children(&self.0).nth(0usize) }

	pub fn item_kind(&self) -> Option<ItemKind> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Attribute(SyntaxNode);
impl std::fmt::Debug for Attribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Attribute {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Attribute {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Attribute }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Attribute {
	pub fn at(&self) -> Option<At> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn token_tree(&self) -> Option<TokenTree> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Name(SyntaxNode);
impl std::fmt::Debug for Name {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Name {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Name {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Name }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Name {
	pub fn ident(&self) -> Option<Ident> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Visibility(SyntaxNode);
impl std::fmt::Debug for Visibility {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Visibility {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Visibility {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Visibility }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Visibility {
	pub fn pub_kw(&self) -> Option<PubKw> { token_children(&self.0).nth(0usize) }
}

pub enum ItemKind {
	Fn(Fn),
	Struct(Struct),
	Enum(Enum),
	TypeAlias(TypeAlias),
	Static(Static),
	Import(Import),
}
impl std::fmt::Debug for ItemKind {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Fn(x) => std::fmt::Debug::fmt(x, f),
			Self::Struct(x) => std::fmt::Debug::fmt(x, f),
			Self::Enum(x) => std::fmt::Debug::fmt(x, f),
			Self::TypeAlias(x) => std::fmt::Debug::fmt(x, f),
			Self::Static(x) => std::fmt::Debug::fmt(x, f),
			Self::Import(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ItemKind {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::Fn => AstNode::cast(node.clone()).map(Self::Fn),
				SyntaxKind::Struct => AstNode::cast(node.clone()).map(Self::Struct),
				SyntaxKind::Enum => AstNode::cast(node.clone()).map(Self::Enum),
				SyntaxKind::TypeAlias => AstNode::cast(node.clone()).map(Self::TypeAlias),
				SyntaxKind::Static => AstNode::cast(node.clone()).map(Self::Static),
				SyntaxKind::Import => AstNode::cast(node.clone()).map(Self::Import),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}
impl AstElement for ItemKind {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Fn| SyntaxKind::Struct
			| SyntaxKind::Enum
			| SyntaxKind::TypeAlias
			| SyntaxKind::Static
			| SyntaxKind::Import)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::Fn(x) => x.span(),
			Self::Struct(x) => x.span(),
			Self::Enum(x) => x.span(),
			Self::TypeAlias(x) => x.span(),
			Self::Static(x) => x.span(),
			Self::Import(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Fn(SyntaxNode);
impl std::fmt::Debug for Fn {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Fn {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Fn {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Fn }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Fn {
	pub fn abi(&self) -> Option<Abi> { node_children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn param_list(&self) -> Option<ParamList> { node_children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { node_children(&self.0).nth(0usize) }

	pub fn fn_body(&self) -> Option<FnBody> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Struct(SyntaxNode);
impl std::fmt::Debug for Struct {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Struct {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Struct {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Struct }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Struct {
	pub fn struct_kw(&self) -> Option<StructKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn fields(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Enum(SyntaxNode);
impl std::fmt::Debug for Enum {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Enum {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Enum {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Enum }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Enum {
	pub fn enum_kw(&self) -> Option<EnumKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn variant_list(&self) -> Option<VariantList> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias(SyntaxNode);
impl std::fmt::Debug for TypeAlias {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TypeAlias {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for TypeAlias {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TypeAlias }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl TypeAlias {
	pub fn type_kw(&self) -> Option<TypeKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Static(SyntaxNode);
impl std::fmt::Debug for Static {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Static {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Static {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Static }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Static {
	pub fn static_kw(&self) -> Option<StaticKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Import(SyntaxNode);
impl std::fmt::Debug for Import {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Import {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Import {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Import }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Import {
	pub fn import_kw(&self) -> Option<ImportKw> { token_children(&self.0).nth(0usize) }

	pub fn import_tree(&self) -> Option<ImportTree> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Abi(SyntaxNode);
impl std::fmt::Debug for Abi {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Abi {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Abi {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Abi }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Abi {
	pub fn extern_kw(&self) -> Option<ExternKw> { token_children(&self.0).nth(0usize) }

	pub fn string_lit(&self) -> Option<StringLit> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParamList(SyntaxNode);
impl std::fmt::Debug for ParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParamList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParamList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ParamList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn params(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RetTy(SyntaxNode);
impl std::fmt::Debug for RetTy {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RetTy {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for RetTy {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RetTy }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl RetTy {
	pub fn arrow(&self) -> Option<Arrow> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

pub enum FnBody {
	Semi(Semi),
	Block(Block),
}
impl std::fmt::Debug for FnBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for FnBody {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::Block => AstNode::cast(node.clone()).map(Self::Block),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Semi => AstToken::cast(tok.clone()).map(Self::Semi),
				_ => None,
			},
		})
	}
}
impl AstElement for FnBody {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Semi| SyntaxKind::Block) }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::Semi(x) => x.span(),
			Self::Block(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Block(SyntaxNode);
impl std::fmt::Debug for Block {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Block {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Block {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Block }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Block {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn statements(&self) -> impl Iterator<Item = Stmt> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Param(SyntaxNode);
impl std::fmt::Debug for Param {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Param {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Param {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Param }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Param {
	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

pub enum Type {
	ArrayType(ArrayType),
	FnType(FnType),
	InferType(InferType),
	PathType(PathType),
	PtrType(PtrType),
}
impl std::fmt::Debug for Type {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayType(x) => std::fmt::Debug::fmt(x, f),
			Self::FnType(x) => std::fmt::Debug::fmt(x, f),
			Self::InferType(x) => std::fmt::Debug::fmt(x, f),
			Self::PathType(x) => std::fmt::Debug::fmt(x, f),
			Self::PtrType(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Type {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayType => AstNode::cast(node.clone()).map(Self::ArrayType),
				SyntaxKind::FnType => AstNode::cast(node.clone()).map(Self::FnType),
				SyntaxKind::InferType => AstNode::cast(node.clone()).map(Self::InferType),
				SyntaxKind::PathType => AstNode::cast(node.clone()).map(Self::PathType),
				SyntaxKind::PtrType => AstNode::cast(node.clone()).map(Self::PtrType),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}
impl AstElement for Type {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ArrayType| SyntaxKind::FnType
			| SyntaxKind::InferType
			| SyntaxKind::PathType
			| SyntaxKind::PtrType)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::ArrayType(x) => x.span(),
			Self::FnType(x) => x.span(),
			Self::InferType(x) => x.span(),
			Self::PathType(x) => x.span(),
			Self::PtrType(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct VariantList(SyntaxNode);
impl std::fmt::Debug for VariantList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for VariantList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for VariantList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::VariantList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl VariantList {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn variants(&self) -> impl Iterator<Item = Name> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

pub enum Expr {
	ContinueKw(ContinueKw),
	ArrayExpr(ArrayExpr),
	InfixExpr(InfixExpr),
	Block(Block),
	BreakExpr(BreakExpr),
	CallExpr(CallExpr),
	CastExpr(CastExpr),
	FieldExpr(FieldExpr),
	ForExpr(ForExpr),
	IfExpr(IfExpr),
	IndexExpr(IndexExpr),
	Literal(Literal),
	LoopExpr(LoopExpr),
	MatchExpr(MatchExpr),
	ParenExpr(ParenExpr),
	PathExpr(PathExpr),
	PrefixExpr(PrefixExpr),
	RefExpr(RefExpr),
	ReturnExpr(ReturnExpr),
	WhileExpr(WhileExpr),
	LetExpr(LetExpr),
}
impl std::fmt::Debug for Expr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ContinueKw(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::InfixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
			Self::BreakExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CallExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CastExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::FieldExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ForExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IfExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IndexExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Literal(x) => std::fmt::Debug::fmt(x, f),
			Self::LoopExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::MatchExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ParenExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PathExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PrefixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::RefExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ReturnExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::WhileExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::LetExpr(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Expr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayExpr => AstNode::cast(node.clone()).map(Self::ArrayExpr),
				SyntaxKind::InfixExpr => AstNode::cast(node.clone()).map(Self::InfixExpr),
				SyntaxKind::Block => AstNode::cast(node.clone()).map(Self::Block),
				SyntaxKind::BreakExpr => AstNode::cast(node.clone()).map(Self::BreakExpr),
				SyntaxKind::CallExpr => AstNode::cast(node.clone()).map(Self::CallExpr),
				SyntaxKind::CastExpr => AstNode::cast(node.clone()).map(Self::CastExpr),
				SyntaxKind::FieldExpr => AstNode::cast(node.clone()).map(Self::FieldExpr),
				SyntaxKind::ForExpr => AstNode::cast(node.clone()).map(Self::ForExpr),
				SyntaxKind::IfExpr => AstNode::cast(node.clone()).map(Self::IfExpr),
				SyntaxKind::IndexExpr => AstNode::cast(node.clone()).map(Self::IndexExpr),
				SyntaxKind::LoopExpr => AstNode::cast(node.clone()).map(Self::LoopExpr),
				SyntaxKind::MatchExpr => AstNode::cast(node.clone()).map(Self::MatchExpr),
				SyntaxKind::ParenExpr => AstNode::cast(node.clone()).map(Self::ParenExpr),
				SyntaxKind::PathExpr => AstNode::cast(node.clone()).map(Self::PathExpr),
				SyntaxKind::PrefixExpr => AstNode::cast(node.clone()).map(Self::PrefixExpr),
				SyntaxKind::RefExpr => AstNode::cast(node.clone()).map(Self::RefExpr),
				SyntaxKind::ReturnExpr => AstNode::cast(node.clone()).map(Self::ReturnExpr),
				SyntaxKind::WhileExpr => AstNode::cast(node.clone()).map(Self::WhileExpr),
				SyntaxKind::LetExpr => AstNode::cast(node.clone()).map(Self::LetExpr),
				_ => None.or_else(|| AstNode::cast(node.clone()).map(Self::Literal)),
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::ContinueKw => AstToken::cast(tok.clone()).map(Self::ContinueKw),
				_ => None,
			},
		})
	}
}
impl AstElement for Expr {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ContinueKw| SyntaxKind::ArrayExpr
			| SyntaxKind::InfixExpr
			| SyntaxKind::Block
			| SyntaxKind::BreakExpr
			| SyntaxKind::CallExpr
			| SyntaxKind::CastExpr
			| SyntaxKind::FieldExpr
			| SyntaxKind::ForExpr
			| SyntaxKind::IfExpr
			| SyntaxKind::IndexExpr
			| SyntaxKind::LoopExpr
			| SyntaxKind::MatchExpr
			| SyntaxKind::ParenExpr
			| SyntaxKind::PathExpr
			| SyntaxKind::PrefixExpr
			| SyntaxKind::RefExpr
			| SyntaxKind::ReturnExpr
			| SyntaxKind::WhileExpr
			| SyntaxKind::LetExpr)
			|| Literal::can_cast(kind)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::ContinueKw(x) => x.span(),
			Self::ArrayExpr(x) => x.span(),
			Self::InfixExpr(x) => x.span(),
			Self::Block(x) => x.span(),
			Self::BreakExpr(x) => x.span(),
			Self::CallExpr(x) => x.span(),
			Self::CastExpr(x) => x.span(),
			Self::FieldExpr(x) => x.span(),
			Self::ForExpr(x) => x.span(),
			Self::IfExpr(x) => x.span(),
			Self::IndexExpr(x) => x.span(),
			Self::Literal(x) => x.span(),
			Self::LoopExpr(x) => x.span(),
			Self::MatchExpr(x) => x.span(),
			Self::ParenExpr(x) => x.span(),
			Self::PathExpr(x) => x.span(),
			Self::PrefixExpr(x) => x.span(),
			Self::RefExpr(x) => x.span(),
			Self::ReturnExpr(x) => x.span(),
			Self::WhileExpr(x) => x.span(),
			Self::LetExpr(x) => x.span(),
		}
	}
}

pub enum ImportTree {
	ListImport(ListImport),
	RenameImport(RenameImport),
}
impl std::fmt::Debug for ImportTree {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ListImport(x) => std::fmt::Debug::fmt(x, f),
			Self::RenameImport(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ImportTree {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ListImport => AstNode::cast(node.clone()).map(Self::ListImport),
				SyntaxKind::RenameImport => AstNode::cast(node.clone()).map(Self::RenameImport),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}
impl AstElement for ImportTree {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ListImport| SyntaxKind::RenameImport) }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::ListImport(x) => x.span(),
			Self::RenameImport(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ListImport(SyntaxNode);
impl std::fmt::Debug for ListImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ListImport {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ListImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ListImport }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ListImport {
	pub fn prefix(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn wildcard(&self) -> Option<Wildcard> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RenameImport(SyntaxNode);
impl std::fmt::Debug for RenameImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RenameImport {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for RenameImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RenameImport }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl RenameImport {
	pub fn path(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }

	pub fn rename(&self) -> Option<Rename> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Path(SyntaxNode);
impl std::fmt::Debug for Path {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Path {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Path {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Path }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Path {
	pub fn scope(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn qualifier(&self) -> impl Iterator<Item = PathSegment> + '_ { node_children(&self.0) }

	pub fn end(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Rename(SyntaxNode);
impl std::fmt::Debug for Rename {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Rename {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for Rename {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Rename }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl Rename {
	pub fn as_kw(&self) -> Option<AsKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

pub enum Wildcard {
	Star(Star),
	ImportTreeList(ImportTreeList),
}
impl std::fmt::Debug for Wildcard {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
			Self::ImportTreeList(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Wildcard {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ImportTreeList => AstNode::cast(node.clone()).map(Self::ImportTreeList),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Star => AstToken::cast(tok.clone()).map(Self::Star),
				_ => None,
			},
		})
	}
}
impl AstElement for Wildcard {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Star| SyntaxKind::ImportTreeList) }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::Star(x) => x.span(),
			Self::ImportTreeList(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportTreeList(SyntaxNode);
impl std::fmt::Debug for ImportTreeList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ImportTreeList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ImportTreeList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportTreeList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ImportTreeList {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn import_trees(&self) -> impl Iterator<Item = ImportTree> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayType(SyntaxNode);
impl std::fmt::Debug for ArrayType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayType {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ArrayType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayType }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ArrayType {
	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FnType(SyntaxNode);
impl std::fmt::Debug for FnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FnType {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for FnType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnType }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl FnType {
	pub fn abi(&self) -> Option<Abi> { node_children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { token_children(&self.0).nth(0usize) }

	pub fn params(&self) -> Option<TyParamList> { node_children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InferType(SyntaxNode);
impl std::fmt::Debug for InferType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InferType {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for InferType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InferType }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl InferType {
	pub fn underscore(&self) -> Option<Underscore> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathType(SyntaxNode);
impl std::fmt::Debug for PathType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathType {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for PathType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathType }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl PathType {
	pub fn path(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PtrType(SyntaxNode);
impl std::fmt::Debug for PtrType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PtrType {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for PtrType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PtrType }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl PtrType {
	pub fn star(&self) -> Option<Star> { token_children(&self.0).nth(0usize) }

	pub fn mut_kw(&self) -> Option<MutKw> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TyParamList(SyntaxNode);
impl std::fmt::Debug for TyParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TyParamList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for TyParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TyParamList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl TyParamList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn types(&self) -> impl Iterator<Item = Type> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

pub enum Stmt {
	Semi(Semi),
	SemiExpr(SemiExpr),
	Expr(Expr),
	Item(Item),
}
impl std::fmt::Debug for Stmt {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::SemiExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Expr(x) => std::fmt::Debug::fmt(x, f),
			Self::Item(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Stmt {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::SemiExpr => AstNode::cast(node.clone()).map(Self::SemiExpr),
				SyntaxKind::Item => AstNode::cast(node.clone()).map(Self::Item),
				_ => None.or_else(|| AstNode::cast(node.clone()).map(Self::Expr)),
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Semi => AstToken::cast(tok.clone()).map(Self::Semi),
				_ => None,
			},
		})
	}
}
impl AstElement for Stmt {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Semi| SyntaxKind::SemiExpr | SyntaxKind::Item) || Expr::can_cast(kind)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::Semi(x) => x.span(),
			Self::SemiExpr(x) => x.span(),
			Self::Expr(x) => x.span(),
			Self::Item(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SemiExpr(SyntaxNode);
impl std::fmt::Debug for SemiExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for SemiExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for SemiExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::SemiExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl SemiExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr(SyntaxNode);
impl std::fmt::Debug for ArrayExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ArrayExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ArrayExpr {
	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn array_init(&self) -> Option<ArrayInit> { node_children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InfixExpr(SyntaxNode);
impl std::fmt::Debug for InfixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InfixExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for InfixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InfixExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl InfixExpr {
	pub fn lhs(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn op(&self) -> Option<InfixOp> { node_children(&self.0).nth(0usize) }

	pub fn rhs(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr(SyntaxNode);
impl std::fmt::Debug for BreakExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for BreakExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for BreakExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BreakExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl BreakExpr {
	pub fn break_kw(&self) -> Option<BreakKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CallExpr(SyntaxNode);
impl std::fmt::Debug for CallExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CallExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for CallExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CallExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl CallExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn arg_list(&self) -> Option<ArgList> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CastExpr(SyntaxNode);
impl std::fmt::Debug for CastExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CastExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for CastExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CastExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl CastExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn as_kw(&self) -> Option<AsKw> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr(SyntaxNode);
impl std::fmt::Debug for FieldExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FieldExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for FieldExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FieldExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl FieldExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ForExpr(SyntaxNode);
impl std::fmt::Debug for ForExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ForExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ForExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ForExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ForExpr {
	pub fn for_kw(&self) -> Option<ForKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn in_kw(&self) -> Option<InKw> { token_children(&self.0).nth(0usize) }

	pub fn iter(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IfExpr(SyntaxNode);
impl std::fmt::Debug for IfExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IfExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for IfExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IfExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl IfExpr {
	pub fn if_kw(&self) -> Option<IfKw> { token_children(&self.0).nth(0usize) }

	pub fn cond(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }

	pub fn else_kw(&self) -> Option<ElseKw> { token_children(&self.0).nth(0usize) }

	pub fn else_(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode);
impl std::fmt::Debug for IndexExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IndexExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for IndexExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IndexExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl IndexExpr {
	pub fn base(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn index(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

pub enum Literal {
	BoolLit(BoolLit),
	CharLit(CharLit),
	FloatLit(FloatLit),
	IntLit(IntLit),
	StringLit(StringLit),
}
impl std::fmt::Debug for Literal {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::BoolLit(x) => std::fmt::Debug::fmt(x, f),
			Self::CharLit(x) => std::fmt::Debug::fmt(x, f),
			Self::FloatLit(x) => std::fmt::Debug::fmt(x, f),
			Self::IntLit(x) => std::fmt::Debug::fmt(x, f),
			Self::StringLit(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Literal {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::BoolLit => AstToken::cast(tok.clone()).map(Self::BoolLit),
				SyntaxKind::CharLit => AstToken::cast(tok.clone()).map(Self::CharLit),
				SyntaxKind::FloatLit => AstToken::cast(tok.clone()).map(Self::FloatLit),
				SyntaxKind::IntLit => AstToken::cast(tok.clone()).map(Self::IntLit),
				SyntaxKind::StringLit => AstToken::cast(tok.clone()).map(Self::StringLit),
				_ => None,
			},
		})
	}
}
impl AstElement for Literal {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::BoolLit| SyntaxKind::CharLit
			| SyntaxKind::FloatLit
			| SyntaxKind::IntLit
			| SyntaxKind::StringLit)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::BoolLit(x) => x.span(),
			Self::CharLit(x) => x.span(),
			Self::FloatLit(x) => x.span(),
			Self::IntLit(x) => x.span(),
			Self::StringLit(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr(SyntaxNode);
impl std::fmt::Debug for LoopExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LoopExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for LoopExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LoopExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl LoopExpr {
	pub fn loop_kw(&self) -> Option<LoopKw> { token_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }

	pub fn while_kw(&self) -> Option<WhileKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr(SyntaxNode);
impl std::fmt::Debug for MatchExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for MatchExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl MatchExpr {
	pub fn match_kw(&self) -> Option<MatchKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn arms(&self) -> impl Iterator<Item = MatchArm> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode);
impl std::fmt::Debug for ParenExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParenExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ParenExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParenExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ParenExpr {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathExpr(SyntaxNode);
impl std::fmt::Debug for PathExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for PathExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl PathExpr {
	pub fn path(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr(SyntaxNode);
impl std::fmt::Debug for PrefixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PrefixExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for PrefixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PrefixExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl PrefixExpr {
	pub fn op(&self) -> Option<PrefixOp> { node_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RefExpr(SyntaxNode);
impl std::fmt::Debug for RefExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RefExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for RefExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RefExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl RefExpr {
	pub fn amp(&self) -> Option<Amp> { token_children(&self.0).nth(0usize) }

	pub fn mut_kw(&self) -> Option<MutKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr(SyntaxNode);
impl std::fmt::Debug for ReturnExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ReturnExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ReturnExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ReturnExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ReturnExpr {
	pub fn return_kw(&self) -> Option<ReturnKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr(SyntaxNode);
impl std::fmt::Debug for WhileExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for WhileExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for WhileExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::WhileExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl WhileExpr {
	pub fn while_kw(&self) -> Option<WhileKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LetExpr(SyntaxNode);
impl std::fmt::Debug for LetExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LetExpr {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for LetExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LetExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl LetExpr {
	pub fn let_kw(&self) -> Option<LetKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

pub enum ArrayInit {
	ArrayList(ArrayList),
	ArrayRepeat(ArrayRepeat),
}
impl std::fmt::Debug for ArrayInit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayList(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayRepeat(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ArrayInit {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayList => AstNode::cast(node.clone()).map(Self::ArrayList),
				SyntaxKind::ArrayRepeat => AstNode::cast(node.clone()).map(Self::ArrayRepeat),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}
impl AstElement for ArrayInit {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ArrayList| SyntaxKind::ArrayRepeat) }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::ArrayList(x) => x.span(),
			Self::ArrayRepeat(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayList(SyntaxNode);
impl std::fmt::Debug for ArrayList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ArrayList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ArrayList {
	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayRepeat(SyntaxNode);
impl std::fmt::Debug for ArrayRepeat {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayRepeat {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ArrayRepeat {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayRepeat }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ArrayRepeat {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

pub enum InfixOp {
	PipePipe(PipePipe),
	AmpAmp(AmpAmp),
	EqEq(EqEq),
	Neq(Neq),
	Leq(Leq),
	Geq(Geq),
	Lt(Lt),
	Gt(Gt),
	Plus(Plus),
	Star(Star),
	Minus(Minus),
	Slash(Slash),
	Percent(Percent),
	Shl(Shl),
	Shr(Shr),
	Caret(Caret),
	Pipe(Pipe),
	Amp(Amp),
	Eq(Eq),
	PlusEq(PlusEq),
	SlashEq(SlashEq),
	StarEq(StarEq),
	PercentEq(PercentEq),
	ShrEq(ShrEq),
	ShlEq(ShlEq),
	MinusEq(MinusEq),
	PipeEq(PipeEq),
	AmpEq(AmpEq),
	CaretEq(CaretEq),
}
impl std::fmt::Debug for InfixOp {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::PipePipe(x) => std::fmt::Debug::fmt(x, f),
			Self::AmpAmp(x) => std::fmt::Debug::fmt(x, f),
			Self::EqEq(x) => std::fmt::Debug::fmt(x, f),
			Self::Neq(x) => std::fmt::Debug::fmt(x, f),
			Self::Leq(x) => std::fmt::Debug::fmt(x, f),
			Self::Geq(x) => std::fmt::Debug::fmt(x, f),
			Self::Lt(x) => std::fmt::Debug::fmt(x, f),
			Self::Gt(x) => std::fmt::Debug::fmt(x, f),
			Self::Plus(x) => std::fmt::Debug::fmt(x, f),
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
			Self::Minus(x) => std::fmt::Debug::fmt(x, f),
			Self::Slash(x) => std::fmt::Debug::fmt(x, f),
			Self::Percent(x) => std::fmt::Debug::fmt(x, f),
			Self::Shl(x) => std::fmt::Debug::fmt(x, f),
			Self::Shr(x) => std::fmt::Debug::fmt(x, f),
			Self::Caret(x) => std::fmt::Debug::fmt(x, f),
			Self::Pipe(x) => std::fmt::Debug::fmt(x, f),
			Self::Amp(x) => std::fmt::Debug::fmt(x, f),
			Self::Eq(x) => std::fmt::Debug::fmt(x, f),
			Self::PlusEq(x) => std::fmt::Debug::fmt(x, f),
			Self::SlashEq(x) => std::fmt::Debug::fmt(x, f),
			Self::StarEq(x) => std::fmt::Debug::fmt(x, f),
			Self::PercentEq(x) => std::fmt::Debug::fmt(x, f),
			Self::ShrEq(x) => std::fmt::Debug::fmt(x, f),
			Self::ShlEq(x) => std::fmt::Debug::fmt(x, f),
			Self::MinusEq(x) => std::fmt::Debug::fmt(x, f),
			Self::PipeEq(x) => std::fmt::Debug::fmt(x, f),
			Self::AmpEq(x) => std::fmt::Debug::fmt(x, f),
			Self::CaretEq(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for InfixOp {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::PipePipe => AstToken::cast(tok.clone()).map(Self::PipePipe),
				SyntaxKind::AmpAmp => AstToken::cast(tok.clone()).map(Self::AmpAmp),
				SyntaxKind::EqEq => AstToken::cast(tok.clone()).map(Self::EqEq),
				SyntaxKind::Neq => AstToken::cast(tok.clone()).map(Self::Neq),
				SyntaxKind::Leq => AstToken::cast(tok.clone()).map(Self::Leq),
				SyntaxKind::Geq => AstToken::cast(tok.clone()).map(Self::Geq),
				SyntaxKind::Lt => AstToken::cast(tok.clone()).map(Self::Lt),
				SyntaxKind::Gt => AstToken::cast(tok.clone()).map(Self::Gt),
				SyntaxKind::Plus => AstToken::cast(tok.clone()).map(Self::Plus),
				SyntaxKind::Star => AstToken::cast(tok.clone()).map(Self::Star),
				SyntaxKind::Minus => AstToken::cast(tok.clone()).map(Self::Minus),
				SyntaxKind::Slash => AstToken::cast(tok.clone()).map(Self::Slash),
				SyntaxKind::Percent => AstToken::cast(tok.clone()).map(Self::Percent),
				SyntaxKind::Shl => AstToken::cast(tok.clone()).map(Self::Shl),
				SyntaxKind::Shr => AstToken::cast(tok.clone()).map(Self::Shr),
				SyntaxKind::Caret => AstToken::cast(tok.clone()).map(Self::Caret),
				SyntaxKind::Pipe => AstToken::cast(tok.clone()).map(Self::Pipe),
				SyntaxKind::Amp => AstToken::cast(tok.clone()).map(Self::Amp),
				SyntaxKind::Eq => AstToken::cast(tok.clone()).map(Self::Eq),
				SyntaxKind::PlusEq => AstToken::cast(tok.clone()).map(Self::PlusEq),
				SyntaxKind::SlashEq => AstToken::cast(tok.clone()).map(Self::SlashEq),
				SyntaxKind::StarEq => AstToken::cast(tok.clone()).map(Self::StarEq),
				SyntaxKind::PercentEq => AstToken::cast(tok.clone()).map(Self::PercentEq),
				SyntaxKind::ShrEq => AstToken::cast(tok.clone()).map(Self::ShrEq),
				SyntaxKind::ShlEq => AstToken::cast(tok.clone()).map(Self::ShlEq),
				SyntaxKind::MinusEq => AstToken::cast(tok.clone()).map(Self::MinusEq),
				SyntaxKind::PipeEq => AstToken::cast(tok.clone()).map(Self::PipeEq),
				SyntaxKind::AmpEq => AstToken::cast(tok.clone()).map(Self::AmpEq),
				SyntaxKind::CaretEq => AstToken::cast(tok.clone()).map(Self::CaretEq),
				_ => None,
			},
		})
	}
}
impl AstElement for InfixOp {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::PipePipe| SyntaxKind::AmpAmp
			| SyntaxKind::EqEq
			| SyntaxKind::Neq
			| SyntaxKind::Leq
			| SyntaxKind::Geq
			| SyntaxKind::Lt
			| SyntaxKind::Gt
			| SyntaxKind::Plus
			| SyntaxKind::Star
			| SyntaxKind::Minus
			| SyntaxKind::Slash
			| SyntaxKind::Percent
			| SyntaxKind::Shl
			| SyntaxKind::Shr
			| SyntaxKind::Caret
			| SyntaxKind::Pipe
			| SyntaxKind::Amp
			| SyntaxKind::Eq
			| SyntaxKind::PlusEq
			| SyntaxKind::SlashEq
			| SyntaxKind::StarEq
			| SyntaxKind::PercentEq
			| SyntaxKind::ShrEq
			| SyntaxKind::ShlEq
			| SyntaxKind::MinusEq
			| SyntaxKind::PipeEq
			| SyntaxKind::AmpEq
			| SyntaxKind::CaretEq)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::PipePipe(x) => x.span(),
			Self::AmpAmp(x) => x.span(),
			Self::EqEq(x) => x.span(),
			Self::Neq(x) => x.span(),
			Self::Leq(x) => x.span(),
			Self::Geq(x) => x.span(),
			Self::Lt(x) => x.span(),
			Self::Gt(x) => x.span(),
			Self::Plus(x) => x.span(),
			Self::Star(x) => x.span(),
			Self::Minus(x) => x.span(),
			Self::Slash(x) => x.span(),
			Self::Percent(x) => x.span(),
			Self::Shl(x) => x.span(),
			Self::Shr(x) => x.span(),
			Self::Caret(x) => x.span(),
			Self::Pipe(x) => x.span(),
			Self::Amp(x) => x.span(),
			Self::Eq(x) => x.span(),
			Self::PlusEq(x) => x.span(),
			Self::SlashEq(x) => x.span(),
			Self::StarEq(x) => x.span(),
			Self::PercentEq(x) => x.span(),
			Self::ShrEq(x) => x.span(),
			Self::ShlEq(x) => x.span(),
			Self::MinusEq(x) => x.span(),
			Self::PipeEq(x) => x.span(),
			Self::AmpEq(x) => x.span(),
			Self::CaretEq(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArgList(SyntaxNode);
impl std::fmt::Debug for ArgList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArgList {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for ArgList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArgList }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl ArgList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchArm(SyntaxNode);
impl std::fmt::Debug for MatchArm {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchArm {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for MatchArm {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchArm }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl MatchArm {
	pub fn value(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn fat_arrow(&self) -> Option<FatArrow> { token_children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }

	pub fn comma(&self) -> Option<Comma> { token_children(&self.0).nth(0usize) }
}

pub enum PrefixOp {
	Minus(Minus),
	Not(Not),
	Star(Star),
}
impl std::fmt::Debug for PrefixOp {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Minus(x) => std::fmt::Debug::fmt(x, f),
			Self::Not(x) => std::fmt::Debug::fmt(x, f),
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for PrefixOp {
	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Minus => AstToken::cast(tok.clone()).map(Self::Minus),
				SyntaxKind::Not => AstToken::cast(tok.clone()).map(Self::Not),
				SyntaxKind::Star => AstToken::cast(tok.clone()).map(Self::Star),
				_ => None,
			},
		})
	}
}
impl AstElement for PrefixOp {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Minus| SyntaxKind::Not | SyntaxKind::Star) }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		match self {
			Self::Minus(x) => x.span(),
			Self::Not(x) => x.span(),
			Self::Star(x) => x.span(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathSegment(SyntaxNode);
impl std::fmt::Debug for PathSegment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathSegment {
	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl AstElement for PathSegment {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathSegment }

	fn cast(elem: SyntaxElement) -> Option<Self> { AstNode::cast(elem.into_node()?) }

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}
}
impl PathSegment {
	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }
}
