// This file is generated by build.rs
// Do not edit

use crate::{generated::*, token::*, *};

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Item {
	Fn(Fn),
	Struct(Struct),
	Enum(Enum),
	TypeAlias(TypeAlias),
	Static(Static),
	Import(Import),
}
impl std::fmt::Debug for Item {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Fn(x) => std::fmt::Debug::fmt(x, f),
			Self::Struct(x) => std::fmt::Debug::fmt(x, f),
			Self::Enum(x) => std::fmt::Debug::fmt(x, f),
			Self::TypeAlias(x) => std::fmt::Debug::fmt(x, f),
			Self::Static(x) => std::fmt::Debug::fmt(x, f),
			Self::Import(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Item {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Item }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::Fn => Fn::cast(node.clone()).map(Self::Fn),
					SyntaxKind::Struct => Struct::cast(node.clone()).map(Self::Struct),
					SyntaxKind::Enum => Enum::cast(node.clone()).map(Self::Enum),
					SyntaxKind::TypeAlias => TypeAlias::cast(node.clone()).map(Self::TypeAlias),
					SyntaxKind::Static => Static::cast(node.clone()).map(Self::Static),
					SyntaxKind::Import => Import::cast(node.clone()).map(Self::Import),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Fn(SyntaxNode);
impl std::fmt::Debug for Fn {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Fn {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Fn }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Fn {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn abi(&self) -> Option<Abi> { node(&self.0) }

	pub fn fn_kw(&self) -> Option<FnKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn param_list(&self) -> Option<ParamList> { node(&self.0) }

	pub fn ret_ty(&self) -> Option<RetTy> { node(&self.0) }

	pub fn fn_body(&self) -> Option<FnBody> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Struct(SyntaxNode);
impl std::fmt::Debug for Struct {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Struct {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Struct }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Struct {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn struct_kw(&self) -> Option<StructKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn l_brace(&self) -> Option<LBrace> { token(&self.0) }

	pub fn fields(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Enum(SyntaxNode);
impl std::fmt::Debug for Enum {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Enum {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Enum }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Enum {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn enum_kw(&self) -> Option<EnumKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn l_brace(&self) -> Option<LBrace> { token(&self.0) }

	pub fn variant_list(&self) -> Option<VariantList> { node(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias(SyntaxNode);
impl std::fmt::Debug for TypeAlias {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TypeAlias {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TypeAlias }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl TypeAlias {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn type_kw(&self) -> Option<TypeKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn eq(&self) -> Option<Eq> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Static(SyntaxNode);
impl std::fmt::Debug for Static {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Static {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Static }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Static {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn static_kw(&self) -> Option<StaticKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn colon(&self) -> Option<Colon> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }

	pub fn eq(&self) -> Option<Eq> { token(&self.0) }

	pub fn init(&self) -> Option<Expr> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Import(SyntaxNode);
impl std::fmt::Debug for Import {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Import {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Import }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Import {
	pub fn visibility(&self) -> Option<Visibility> { node(&self.0) }

	pub fn import_kw(&self) -> Option<ImportKw> { token(&self.0) }

	pub fn import_tree(&self) -> Option<ImportTree> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Visibility(SyntaxNode);
impl std::fmt::Debug for Visibility {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Visibility {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Visibility }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Visibility {
	pub fn pub_kw(&self) -> Option<PubKw> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Abi(SyntaxNode);
impl std::fmt::Debug for Abi {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Abi {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Abi }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Abi {
	pub fn extern_kw(&self) -> Option<ExternKw> { token(&self.0) }

	pub fn string_lit(&self) -> Option<StringLit> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Name(SyntaxNode);
impl std::fmt::Debug for Name {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Name {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Name }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Name {
	pub fn ident(&self) -> Option<Ident> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParamList(SyntaxNode);
impl std::fmt::Debug for ParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParamList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ParamList {
	pub fn l_paren(&self) -> Option<LParen> { token(&self.0) }

	pub fn params(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RetTy(SyntaxNode);
impl std::fmt::Debug for RetTy {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RetTy {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RetTy }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl RetTy {
	pub fn arrow(&self) -> Option<Arrow> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum FnBody {
	Semi(Semi),
	Block(Block),
}
impl std::fmt::Debug for FnBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for FnBody {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnBody }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::Block => Block::cast(node.clone()).map(Self::Block),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					SyntaxKind::Semi => Semi::cast(tok.clone()).map(Self::Semi),
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Block(SyntaxNode);
impl std::fmt::Debug for Block {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Block {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Block }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Block {
	pub fn l_brace(&self) -> Option<LBrace> { token(&self.0) }

	pub fn statements(&self) -> impl Iterator<Item = Stmt> + '_ { node_children(&self.0) }

	pub fn tail(&self) -> Option<Expr> { node(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Param(SyntaxNode);
impl std::fmt::Debug for Param {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Param {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Param }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Param {
	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn colon(&self) -> Option<Colon> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Type(SyntaxNode);
impl std::fmt::Debug for Type {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Type {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Type }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Type {
	pub fn array_type(&self) -> Option<ArrayType> { node(&self.0) }

	pub fn fn_type(&self) -> Option<FnType> { node(&self.0) }

	pub fn infer_type(&self) -> Option<InferType> { node(&self.0) }

	pub fn path_type(&self) -> Option<PathType> { node(&self.0) }

	pub fn ptr_type(&self) -> Option<PtrType> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct VariantList(SyntaxNode);
impl std::fmt::Debug for VariantList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for VariantList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::VariantList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl VariantList {
	pub fn names(&self) -> impl Iterator<Item = Name> + '_ { node_children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Expr {
	ArrayExpr(ArrayExpr),
	BinExpr(BinExpr),
	Block(Block),
	BreakExpr(BreakExpr),
	CallExpr(CallExpr),
	CastExpr(CastExpr),
	ContinueExpr(ContinueExpr),
	FieldExpr(FieldExpr),
	ForExpr(ForExpr),
	IfExpr(IfExpr),
	IndexExpr(IndexExpr),
	Literal(Literal),
	LoopExpr(LoopExpr),
	MatchExpr(MatchExpr),
	ParenExpr(ParenExpr),
	PathExpr(PathExpr),
	PrefixExpr(PrefixExpr),
	ReturnExpr(ReturnExpr),
	WhileExpr(WhileExpr),
	LetExpr(LetExpr),
}
impl std::fmt::Debug for Expr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::BinExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
			Self::BreakExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CallExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CastExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ContinueExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::FieldExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ForExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IfExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IndexExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Literal(x) => std::fmt::Debug::fmt(x, f),
			Self::LoopExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::MatchExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ParenExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PathExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PrefixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ReturnExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::WhileExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::LetExpr(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Expr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Expr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::ArrayExpr => ArrayExpr::cast(node.clone()).map(Self::ArrayExpr),
					SyntaxKind::BinExpr => BinExpr::cast(node.clone()).map(Self::BinExpr),
					SyntaxKind::Block => Block::cast(node.clone()).map(Self::Block),
					SyntaxKind::BreakExpr => BreakExpr::cast(node.clone()).map(Self::BreakExpr),
					SyntaxKind::CallExpr => CallExpr::cast(node.clone()).map(Self::CallExpr),
					SyntaxKind::CastExpr => CastExpr::cast(node.clone()).map(Self::CastExpr),
					SyntaxKind::ContinueExpr => ContinueExpr::cast(node.clone()).map(Self::ContinueExpr),
					SyntaxKind::FieldExpr => FieldExpr::cast(node.clone()).map(Self::FieldExpr),
					SyntaxKind::ForExpr => ForExpr::cast(node.clone()).map(Self::ForExpr),
					SyntaxKind::IfExpr => IfExpr::cast(node.clone()).map(Self::IfExpr),
					SyntaxKind::IndexExpr => IndexExpr::cast(node.clone()).map(Self::IndexExpr),
					SyntaxKind::Literal => Literal::cast(node.clone()).map(Self::Literal),
					SyntaxKind::LoopExpr => LoopExpr::cast(node.clone()).map(Self::LoopExpr),
					SyntaxKind::MatchExpr => MatchExpr::cast(node.clone()).map(Self::MatchExpr),
					SyntaxKind::ParenExpr => ParenExpr::cast(node.clone()).map(Self::ParenExpr),
					SyntaxKind::PathExpr => PathExpr::cast(node.clone()).map(Self::PathExpr),
					SyntaxKind::PrefixExpr => PrefixExpr::cast(node.clone()).map(Self::PrefixExpr),
					SyntaxKind::ReturnExpr => ReturnExpr::cast(node.clone()).map(Self::ReturnExpr),
					SyntaxKind::WhileExpr => WhileExpr::cast(node.clone()).map(Self::WhileExpr),
					SyntaxKind::LetExpr => LetExpr::cast(node.clone()).map(Self::LetExpr),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ImportTree {
	ListImport(ListImport),
	RenameImport(RenameImport),
}
impl std::fmt::Debug for ImportTree {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ListImport(x) => std::fmt::Debug::fmt(x, f),
			Self::RenameImport(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ImportTree {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportTree }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::ListImport => ListImport::cast(node.clone()).map(Self::ListImport),
					SyntaxKind::RenameImport => RenameImport::cast(node.clone()).map(Self::RenameImport),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ListImport(SyntaxNode);
impl std::fmt::Debug for ListImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ListImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ListImport }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ListImport {
	pub fn prefix(&self) -> Option<Path> { node(&self.0) }

	pub fn dot(&self) -> Option<Dot> { token(&self.0) }

	pub fn wildcard(&self) -> Option<Wildcard> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RenameImport(SyntaxNode);
impl std::fmt::Debug for RenameImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RenameImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RenameImport }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl RenameImport {
	pub fn path(&self) -> Option<Path> { node(&self.0) }

	pub fn rename(&self) -> Option<Rename> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Path(SyntaxNode);
impl std::fmt::Debug for Path {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Path {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Path }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Path {
	pub fn qualifier(&self) -> Option<Path> { node(&self.0) }

	pub fn dot(&self) -> Option<Dot> { token(&self.0) }

	pub fn segment(&self) -> Option<PathSegment> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Rename(SyntaxNode);
impl std::fmt::Debug for Rename {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Rename {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Rename }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Rename {
	pub fn as_kw(&self) -> Option<AsKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Wildcard {
	Star(Star),
	ImportTreeList(ImportTreeList),
}
impl std::fmt::Debug for Wildcard {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
			Self::ImportTreeList(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Wildcard {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Wildcard }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::ImportTreeList => ImportTreeList::cast(node.clone()).map(Self::ImportTreeList),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					SyntaxKind::Star => Star::cast(tok.clone()).map(Self::Star),
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportTreeList(SyntaxNode);
impl std::fmt::Debug for ImportTreeList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ImportTreeList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportTreeList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ImportTreeList {
	pub fn l_brace(&self) -> Option<LBrace> { token(&self.0) }

	pub fn import_trees(&self) -> impl Iterator<Item = ImportTree> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayType(SyntaxNode);
impl std::fmt::Debug for ArrayType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayType {
	pub fn l_bracket(&self) -> Option<LBracket> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }

	pub fn len(&self) -> Option<Expr> { node(&self.0) }

	pub fn r_bracket(&self) -> Option<RBracket> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FnType(SyntaxNode);
impl std::fmt::Debug for FnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FnType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl FnType {
	pub fn abi(&self) -> Option<Abi> { node(&self.0) }

	pub fn fn_kw(&self) -> Option<FnKw> { token(&self.0) }

	pub fn ty_param_list(&self) -> Option<TyParamList> { node(&self.0) }

	pub fn ret_ty(&self) -> Option<RetTy> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InferType(SyntaxNode);
impl std::fmt::Debug for InferType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InferType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InferType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl InferType {
	pub fn underscore(&self) -> Option<Underscore> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathType(SyntaxNode);
impl std::fmt::Debug for PathType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PathType {
	pub fn path(&self) -> Option<Path> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PtrType(SyntaxNode);
impl std::fmt::Debug for PtrType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PtrType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PtrType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PtrType {
	pub fn star(&self) -> Option<Star> { token(&self.0) }

	pub fn ptr_mutability(&self) -> Option<PtrMutability> { node(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TyParamList(SyntaxNode);
impl std::fmt::Debug for TyParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TyParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TyParamList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl TyParamList {
	pub fn l_paren(&self) -> Option<LParen> { token(&self.0) }

	pub fn types(&self) -> impl Iterator<Item = Type> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum PtrMutability {
	ConstKw(ConstKw),
	MutKw(MutKw),
}
impl std::fmt::Debug for PtrMutability {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ConstKw(x) => std::fmt::Debug::fmt(x, f),
			Self::MutKw(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for PtrMutability {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PtrMutability }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					SyntaxKind::ConstKw => ConstKw::cast(tok.clone()).map(Self::ConstKw),
					SyntaxKind::MutKw => MutKw::cast(tok.clone()).map(Self::MutKw),
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
	Semi(Semi),
	ExprStmt(ExprStmt),
	Item(Item),
}
impl std::fmt::Debug for Stmt {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::ExprStmt(x) => std::fmt::Debug::fmt(x, f),
			Self::Item(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Stmt {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Stmt }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::ExprStmt => ExprStmt::cast(node.clone()).map(Self::ExprStmt),
					SyntaxKind::Item => Item::cast(node.clone()).map(Self::Item),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					SyntaxKind::Semi => Semi::cast(tok.clone()).map(Self::Semi),
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt(SyntaxNode);
impl std::fmt::Debug for ExprStmt {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ExprStmt {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ExprStmt }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ExprStmt {
	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr(SyntaxNode);
impl std::fmt::Debug for ArrayExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayExpr {
	pub fn l_bracket(&self) -> Option<LBracket> { token(&self.0) }

	pub fn array_init(&self) -> Option<ArrayInit> { node(&self.0) }

	pub fn r_bracket(&self) -> Option<RBracket> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(SyntaxNode);
impl std::fmt::Debug for BinExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for BinExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BinExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl BinExpr {
	pub fn lhs(&self) -> Option<Expr> { node(&self.0) }

	pub fn operator(&self) -> Option<Operator> { token(&self.0) }

	pub fn rhs(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr(SyntaxNode);
impl std::fmt::Debug for BreakExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for BreakExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BreakExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl BreakExpr {
	pub fn break_kw(&self) -> Option<BreakKw> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CallExpr(SyntaxNode);
impl std::fmt::Debug for CallExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CallExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CallExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl CallExpr {
	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn arg_list(&self) -> Option<ArgList> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CastExpr(SyntaxNode);
impl std::fmt::Debug for CastExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CastExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CastExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl CastExpr {
	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn as_kw(&self) -> Option<AsKw> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr(SyntaxNode);
impl std::fmt::Debug for ContinueExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ContinueExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ContinueExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ContinueExpr {
	pub fn continue_kw(&self) -> Option<ContinueKw> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr(SyntaxNode);
impl std::fmt::Debug for FieldExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FieldExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FieldExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl FieldExpr {
	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn dot(&self) -> Option<Dot> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ForExpr(SyntaxNode);
impl std::fmt::Debug for ForExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ForExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ForExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ForExpr {
	pub fn for_kw(&self) -> Option<ForKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn in_kw(&self) -> Option<InKw> { token(&self.0) }

	pub fn iter(&self) -> Option<Expr> { node(&self.0) }

	pub fn body(&self) -> Option<Block> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IfExpr(SyntaxNode);
impl std::fmt::Debug for IfExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IfExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IfExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl IfExpr {
	pub fn if_kw(&self) -> Option<IfKw> { token(&self.0) }

	pub fn cond(&self) -> Option<Expr> { node(&self.0) }

	pub fn then(&self) -> Option<Block> { node(&self.0) }

	pub fn else_kw(&self) -> Option<ElseKw> { token(&self.0) }

	pub fn else_expr(&self) -> Option<ElseExpr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode);
impl std::fmt::Debug for IndexExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IndexExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IndexExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl IndexExpr {
	pub fn base(&self) -> Option<Expr> { node(&self.0) }

	pub fn l_bracket(&self) -> Option<LBracket> { token(&self.0) }

	pub fn index(&self) -> Option<Expr> { node(&self.0) }

	pub fn r_bracket(&self) -> Option<RBracket> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Literal {
	BoolLit(BoolLit),
	CharLit(CharLit),
	FloatLit(FloatLit),
	IntLit(IntLit),
	StringLit(StringLit),
}
impl std::fmt::Debug for Literal {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::BoolLit(x) => std::fmt::Debug::fmt(x, f),
			Self::CharLit(x) => std::fmt::Debug::fmt(x, f),
			Self::FloatLit(x) => std::fmt::Debug::fmt(x, f),
			Self::IntLit(x) => std::fmt::Debug::fmt(x, f),
			Self::StringLit(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Literal {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Literal }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					SyntaxKind::BoolLit => BoolLit::cast(tok.clone()).map(Self::BoolLit),
					SyntaxKind::CharLit => CharLit::cast(tok.clone()).map(Self::CharLit),
					SyntaxKind::FloatLit => FloatLit::cast(tok.clone()).map(Self::FloatLit),
					SyntaxKind::IntLit => IntLit::cast(tok.clone()).map(Self::IntLit),
					SyntaxKind::StringLit => StringLit::cast(tok.clone()).map(Self::StringLit),
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr(SyntaxNode);
impl std::fmt::Debug for LoopExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LoopExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LoopExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl LoopExpr {
	pub fn loop_kw(&self) -> Option<LoopKw> { token(&self.0) }

	pub fn body(&self) -> Option<Block> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr(SyntaxNode);
impl std::fmt::Debug for MatchExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl MatchExpr {
	pub fn match_kw(&self) -> Option<MatchKw> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn l_brace(&self) -> Option<LBrace> { token(&self.0) }

	pub fn arms(&self) -> impl Iterator<Item = MatchArm> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode);
impl std::fmt::Debug for ParenExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParenExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParenExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ParenExpr {
	pub fn l_paren(&self) -> Option<LParen> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathExpr(SyntaxNode);
impl std::fmt::Debug for PathExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PathExpr {
	pub fn path(&self) -> Option<Path> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr(SyntaxNode);
impl std::fmt::Debug for PrefixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PrefixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PrefixExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PrefixExpr {
	pub fn operator(&self) -> Option<Operator> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr(SyntaxNode);
impl std::fmt::Debug for ReturnExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ReturnExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ReturnExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ReturnExpr {
	pub fn return_kw(&self) -> Option<ReturnKw> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr(SyntaxNode);
impl std::fmt::Debug for WhileExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for WhileExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::WhileExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl WhileExpr {
	pub fn while_kw(&self) -> Option<WhileKw> { token(&self.0) }

	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn body(&self) -> Option<Block> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LetExpr(SyntaxNode);
impl std::fmt::Debug for LetExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LetExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LetExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl LetExpr {
	pub fn let_kw(&self) -> Option<LetKw> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }

	pub fn colon(&self) -> Option<Colon> { token(&self.0) }

	pub fn type_(&self) -> Option<Type> { node(&self.0) }

	pub fn eq(&self) -> Option<Eq> { token(&self.0) }

	pub fn init(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ArrayInit {
	ArrayList(ArrayList),
	ArrayRepeat(ArrayRepeat),
}
impl std::fmt::Debug for ArrayInit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayList(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayRepeat(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ArrayInit {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayInit }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::ArrayList => ArrayList::cast(node.clone()).map(Self::ArrayList),
					SyntaxKind::ArrayRepeat => ArrayRepeat::cast(node.clone()).map(Self::ArrayRepeat),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayList(SyntaxNode);
impl std::fmt::Debug for ArrayList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayList {
	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayRepeat(SyntaxNode);
impl std::fmt::Debug for ArrayRepeat {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayRepeat {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayRepeat }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayRepeat {
	pub fn expr(&self) -> Option<Expr> { node(&self.0) }

	pub fn semi(&self) -> Option<Semi> { token(&self.0) }

	pub fn len(&self) -> Option<Expr> { node(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArgList(SyntaxNode);
impl std::fmt::Debug for ArgList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArgList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArgList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArgList {
	pub fn l_paren(&self) -> Option<LParen> { token(&self.0) }

	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ElseExpr {
	IfExpr(IfExpr),
	Block(Block),
}
impl std::fmt::Debug for ElseExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::IfExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ElseExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ElseExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			node.children_with_tokens().find_map(|x| match x {
				SyntaxElementRef::Node(node) => match node.kind() {
					SyntaxKind::IfExpr => IfExpr::cast(node.clone()).map(Self::IfExpr),
					SyntaxKind::Block => Block::cast(node.clone()).map(Self::Block),
					_ => None,
				},
				SyntaxElementRef::Token(tok) => match tok.kind() {
					_ => None,
				},
			})
		} else {
			None
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchArm(SyntaxNode);
impl std::fmt::Debug for MatchArm {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchArm {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchArm }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl MatchArm {
	pub fn value(&self) -> Option<Expr> { node(&self.0) }

	pub fn fat_arrow(&self) -> Option<FatArrow> { token(&self.0) }

	pub fn then(&self) -> Option<Expr> { node(&self.0) }

	pub fn comma(&self) -> Option<Comma> { token(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathSegment(SyntaxNode);
impl std::fmt::Debug for PathSegment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathSegment {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathSegment }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PathSegment {
	pub fn dot(&self) -> Option<Dot> { token(&self.0) }

	pub fn name(&self) -> Option<Name> { node(&self.0) }
}
