
#![allow(clippy::all)]
// This file is generated by build.rs
// Do not edit

use diagnostics::FileSpan;

use crate::{generated::*, token::*, *};

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Path(SyntaxNode);
impl std::fmt::Debug for Path {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Path {}
impl AstElement for Path {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Path }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Path {
	pub fn path_segments(&self) -> impl Iterator<Item = PathSegment> + '_ { children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum PathSegment {
	Dot(Dot),
	Name(Name),
}
impl std::fmt::Debug for PathSegment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Dot(x) => std::fmt::Debug::fmt(x, f),
			Self::Name(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for PathSegment {}
impl AstElement for PathSegment {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Dot| SyntaxKind::Name) }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::Name => AstElement::cast(elem.clone()).map(Self::Name),
			SyntaxKind::Dot => AstElement::cast(elem.clone()).map(Self::Dot),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::Dot(x) => x.span(),
			Self::Name(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::Dot(x) => x.inner(),
			Self::Name(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Name(SyntaxNode);
impl std::fmt::Debug for Name {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Name {}
impl AstElement for Name {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Name }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Name {
	pub fn ident(&self) -> Option<Ident> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct File(SyntaxNode);
impl std::fmt::Debug for File {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for File {}
impl AstElement for File {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::File }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl File {
	pub fn items(&self) -> impl Iterator<Item = Item> + '_ { children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Item(SyntaxNode);
impl std::fmt::Debug for Item {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Item {}
impl AstElement for Item {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Item }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Item {
	pub fn attributes(&self) -> impl Iterator<Item = Attribute> + '_ { children(&self.0) }

	pub fn visibility(&self) -> Option<Visibility> { children(&self.0).nth(0usize) }

	pub fn item_kind(&self) -> Option<ItemKind> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Attribute(SyntaxNode);
impl std::fmt::Debug for Attribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Attribute {}
impl AstElement for Attribute {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Attribute }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Attribute {
	pub fn at(&self) -> Option<At> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn token_tree(&self) -> Option<TokenTree> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Visibility(SyntaxNode);
impl std::fmt::Debug for Visibility {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Visibility {}
impl AstElement for Visibility {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Visibility }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Visibility {
	pub fn pub_kw(&self) -> Option<PubKw> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ItemKind {
	Fn(Fn),
	Struct(Struct),
	Enum(Enum),
	TypeAlias(TypeAlias),
	Static(Static),
	Import(Import),
}
impl std::fmt::Debug for ItemKind {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Fn(x) => std::fmt::Debug::fmt(x, f),
			Self::Struct(x) => std::fmt::Debug::fmt(x, f),
			Self::Enum(x) => std::fmt::Debug::fmt(x, f),
			Self::TypeAlias(x) => std::fmt::Debug::fmt(x, f),
			Self::Static(x) => std::fmt::Debug::fmt(x, f),
			Self::Import(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ItemKind {}
impl AstElement for ItemKind {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Fn| SyntaxKind::Struct
			| SyntaxKind::Enum
			| SyntaxKind::TypeAlias
			| SyntaxKind::Static
			| SyntaxKind::Import)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::Fn => AstElement::cast(elem.clone()).map(Self::Fn),
			SyntaxKind::Struct => AstElement::cast(elem.clone()).map(Self::Struct),
			SyntaxKind::Enum => AstElement::cast(elem.clone()).map(Self::Enum),
			SyntaxKind::TypeAlias => AstElement::cast(elem.clone()).map(Self::TypeAlias),
			SyntaxKind::Static => AstElement::cast(elem.clone()).map(Self::Static),
			SyntaxKind::Import => AstElement::cast(elem.clone()).map(Self::Import),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::Fn(x) => x.span(),
			Self::Struct(x) => x.span(),
			Self::Enum(x) => x.span(),
			Self::TypeAlias(x) => x.span(),
			Self::Static(x) => x.span(),
			Self::Import(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::Fn(x) => x.inner(),
			Self::Struct(x) => x.inner(),
			Self::Enum(x) => x.inner(),
			Self::TypeAlias(x) => x.inner(),
			Self::Static(x) => x.inner(),
			Self::Import(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Fn(SyntaxNode);
impl std::fmt::Debug for Fn {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Fn {}
impl AstElement for Fn {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Fn }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Fn {
	pub fn abi(&self) -> Option<Abi> { children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn param_list(&self) -> Option<ParamList> { children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { children(&self.0).nth(0usize) }

	pub fn fn_body(&self) -> Option<FnBody> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Struct(SyntaxNode);
impl std::fmt::Debug for Struct {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Struct {}
impl AstElement for Struct {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Struct }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Struct {
	pub fn struct_kw(&self) -> Option<StructKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { children(&self.0).nth(0usize) }

	pub fn fields(&self) -> impl Iterator<Item = Param> + '_ { children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Enum(SyntaxNode);
impl std::fmt::Debug for Enum {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Enum {}
impl AstElement for Enum {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Enum }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Enum {
	pub fn enum_kw(&self) -> Option<EnumKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn variant_list(&self) -> Option<VariantList> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias(SyntaxNode);
impl std::fmt::Debug for TypeAlias {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TypeAlias {}
impl AstElement for TypeAlias {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TypeAlias }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl TypeAlias {
	pub fn type_kw(&self) -> Option<TypeKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Static(SyntaxNode);
impl std::fmt::Debug for Static {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Static {}
impl AstElement for Static {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Static }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Static {
	pub fn static_kw(&self) -> Option<StaticKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Import(SyntaxNode);
impl std::fmt::Debug for Import {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Import {}
impl AstElement for Import {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Import }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Import {
	pub fn import_kw(&self) -> Option<ImportKw> { children(&self.0).nth(0usize) }

	pub fn import_tree(&self) -> Option<ImportTree> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Abi(SyntaxNode);
impl std::fmt::Debug for Abi {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Abi {}
impl AstElement for Abi {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Abi }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Abi {
	pub fn extern_kw(&self) -> Option<ExternKw> { children(&self.0).nth(0usize) }

	pub fn string_lit(&self) -> Option<StringLit> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParamList(SyntaxNode);
impl std::fmt::Debug for ParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParamList {}
impl AstElement for ParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParamList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ParamList {
	pub fn l_paren(&self) -> Option<LParen> { children(&self.0).nth(0usize) }

	pub fn params(&self) -> impl Iterator<Item = Param> + '_ { children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RetTy(SyntaxNode);
impl std::fmt::Debug for RetTy {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RetTy {}
impl AstElement for RetTy {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RetTy }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl RetTy {
	pub fn arrow(&self) -> Option<Arrow> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum FnBody {
	Semi(Semi),
	Block(Block),
}
impl std::fmt::Debug for FnBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for FnBody {}
impl AstElement for FnBody {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Semi| SyntaxKind::Block) }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::Block => AstElement::cast(elem.clone()).map(Self::Block),
			SyntaxKind::Semi => AstElement::cast(elem.clone()).map(Self::Semi),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::Semi(x) => x.span(),
			Self::Block(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::Semi(x) => x.inner(),
			Self::Block(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Block(SyntaxNode);
impl std::fmt::Debug for Block {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Block {}
impl AstElement for Block {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Block }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Block {
	pub fn l_brace(&self) -> Option<LBrace> { children(&self.0).nth(0usize) }

	pub fn statements(&self) -> impl Iterator<Item = Stmt> + '_ { children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Param(SyntaxNode);
impl std::fmt::Debug for Param {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Param {}
impl AstElement for Param {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Param }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Param {
	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Type {
	ArrayType(ArrayType),
	FnType(FnType),
	InferType(InferType),
	PathType(PathType),
	PtrType(PtrType),
}
impl std::fmt::Debug for Type {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayType(x) => std::fmt::Debug::fmt(x, f),
			Self::FnType(x) => std::fmt::Debug::fmt(x, f),
			Self::InferType(x) => std::fmt::Debug::fmt(x, f),
			Self::PathType(x) => std::fmt::Debug::fmt(x, f),
			Self::PtrType(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Type {}
impl AstElement for Type {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ArrayType| SyntaxKind::FnType
			| SyntaxKind::InferType
			| SyntaxKind::PathType
			| SyntaxKind::PtrType)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::ArrayType => AstElement::cast(elem.clone()).map(Self::ArrayType),
			SyntaxKind::FnType => AstElement::cast(elem.clone()).map(Self::FnType),
			SyntaxKind::InferType => AstElement::cast(elem.clone()).map(Self::InferType),
			SyntaxKind::PathType => AstElement::cast(elem.clone()).map(Self::PathType),
			SyntaxKind::PtrType => AstElement::cast(elem.clone()).map(Self::PtrType),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::ArrayType(x) => x.span(),
			Self::FnType(x) => x.span(),
			Self::InferType(x) => x.span(),
			Self::PathType(x) => x.span(),
			Self::PtrType(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::ArrayType(x) => x.inner(),
			Self::FnType(x) => x.inner(),
			Self::InferType(x) => x.inner(),
			Self::PathType(x) => x.inner(),
			Self::PtrType(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct VariantList(SyntaxNode);
impl std::fmt::Debug for VariantList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for VariantList {}
impl AstElement for VariantList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::VariantList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl VariantList {
	pub fn l_brace(&self) -> Option<LBrace> { children(&self.0).nth(0usize) }

	pub fn variants(&self) -> impl Iterator<Item = Name> + '_ { children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Expr {
	ContinueKw(ContinueKw),
	ArrayExpr(ArrayExpr),
	InfixExpr(InfixExpr),
	Block(Block),
	BreakExpr(BreakExpr),
	CallExpr(CallExpr),
	CastExpr(CastExpr),
	FieldExpr(FieldExpr),
	ForExpr(ForExpr),
	IfExpr(IfExpr),
	IndexExpr(IndexExpr),
	Literal(Literal),
	LoopExpr(LoopExpr),
	MatchExpr(MatchExpr),
	ParenExpr(ParenExpr),
	PathExpr(PathExpr),
	PrefixExpr(PrefixExpr),
	RefExpr(RefExpr),
	ReturnExpr(ReturnExpr),
	WhileExpr(WhileExpr),
	LetExpr(LetExpr),
}
impl std::fmt::Debug for Expr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ContinueKw(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::InfixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
			Self::BreakExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CallExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CastExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::FieldExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ForExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IfExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IndexExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Literal(x) => std::fmt::Debug::fmt(x, f),
			Self::LoopExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::MatchExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ParenExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PathExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::PrefixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::RefExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ReturnExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::WhileExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::LetExpr(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Expr {}
impl AstElement for Expr {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ContinueKw| SyntaxKind::ArrayExpr
			| SyntaxKind::InfixExpr
			| SyntaxKind::Block
			| SyntaxKind::BreakExpr
			| SyntaxKind::CallExpr
			| SyntaxKind::CastExpr
			| SyntaxKind::FieldExpr
			| SyntaxKind::ForExpr
			| SyntaxKind::IfExpr
			| SyntaxKind::IndexExpr
			| SyntaxKind::LoopExpr
			| SyntaxKind::MatchExpr
			| SyntaxKind::ParenExpr
			| SyntaxKind::PathExpr
			| SyntaxKind::PrefixExpr
			| SyntaxKind::RefExpr
			| SyntaxKind::ReturnExpr
			| SyntaxKind::WhileExpr
			| SyntaxKind::LetExpr)
			|| Literal::can_cast(kind)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::ArrayExpr => AstElement::cast(elem.clone()).map(Self::ArrayExpr),
			SyntaxKind::InfixExpr => AstElement::cast(elem.clone()).map(Self::InfixExpr),
			SyntaxKind::Block => AstElement::cast(elem.clone()).map(Self::Block),
			SyntaxKind::BreakExpr => AstElement::cast(elem.clone()).map(Self::BreakExpr),
			SyntaxKind::CallExpr => AstElement::cast(elem.clone()).map(Self::CallExpr),
			SyntaxKind::CastExpr => AstElement::cast(elem.clone()).map(Self::CastExpr),
			SyntaxKind::FieldExpr => AstElement::cast(elem.clone()).map(Self::FieldExpr),
			SyntaxKind::ForExpr => AstElement::cast(elem.clone()).map(Self::ForExpr),
			SyntaxKind::IfExpr => AstElement::cast(elem.clone()).map(Self::IfExpr),
			SyntaxKind::IndexExpr => AstElement::cast(elem.clone()).map(Self::IndexExpr),
			SyntaxKind::LoopExpr => AstElement::cast(elem.clone()).map(Self::LoopExpr),
			SyntaxKind::MatchExpr => AstElement::cast(elem.clone()).map(Self::MatchExpr),
			SyntaxKind::ParenExpr => AstElement::cast(elem.clone()).map(Self::ParenExpr),
			SyntaxKind::PathExpr => AstElement::cast(elem.clone()).map(Self::PathExpr),
			SyntaxKind::PrefixExpr => AstElement::cast(elem.clone()).map(Self::PrefixExpr),
			SyntaxKind::RefExpr => AstElement::cast(elem.clone()).map(Self::RefExpr),
			SyntaxKind::ReturnExpr => AstElement::cast(elem.clone()).map(Self::ReturnExpr),
			SyntaxKind::WhileExpr => AstElement::cast(elem.clone()).map(Self::WhileExpr),
			SyntaxKind::LetExpr => AstElement::cast(elem.clone()).map(Self::LetExpr),
			SyntaxKind::ContinueKw => AstElement::cast(elem.clone()).map(Self::ContinueKw),
			_ => None,
		}
		.or_else(|| AstElement::cast(elem.clone()).map(Self::Literal))
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::ContinueKw(x) => x.span(),
			Self::ArrayExpr(x) => x.span(),
			Self::InfixExpr(x) => x.span(),
			Self::Block(x) => x.span(),
			Self::BreakExpr(x) => x.span(),
			Self::CallExpr(x) => x.span(),
			Self::CastExpr(x) => x.span(),
			Self::FieldExpr(x) => x.span(),
			Self::ForExpr(x) => x.span(),
			Self::IfExpr(x) => x.span(),
			Self::IndexExpr(x) => x.span(),
			Self::Literal(x) => x.span(),
			Self::LoopExpr(x) => x.span(),
			Self::MatchExpr(x) => x.span(),
			Self::ParenExpr(x) => x.span(),
			Self::PathExpr(x) => x.span(),
			Self::PrefixExpr(x) => x.span(),
			Self::RefExpr(x) => x.span(),
			Self::ReturnExpr(x) => x.span(),
			Self::WhileExpr(x) => x.span(),
			Self::LetExpr(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::ContinueKw(x) => x.inner(),
			Self::ArrayExpr(x) => x.inner(),
			Self::InfixExpr(x) => x.inner(),
			Self::Block(x) => x.inner(),
			Self::BreakExpr(x) => x.inner(),
			Self::CallExpr(x) => x.inner(),
			Self::CastExpr(x) => x.inner(),
			Self::FieldExpr(x) => x.inner(),
			Self::ForExpr(x) => x.inner(),
			Self::IfExpr(x) => x.inner(),
			Self::IndexExpr(x) => x.inner(),
			Self::Literal(x) => x.inner(),
			Self::LoopExpr(x) => x.inner(),
			Self::MatchExpr(x) => x.inner(),
			Self::ParenExpr(x) => x.inner(),
			Self::PathExpr(x) => x.inner(),
			Self::PrefixExpr(x) => x.inner(),
			Self::RefExpr(x) => x.inner(),
			Self::ReturnExpr(x) => x.inner(),
			Self::WhileExpr(x) => x.inner(),
			Self::LetExpr(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Rename(SyntaxNode);
impl std::fmt::Debug for Rename {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Rename {}
impl AstElement for Rename {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Rename }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl Rename {
	pub fn as_kw(&self) -> Option<AsKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ImportTree {
	ListImport(ListImport),
	RenameImport(RenameImport),
}
impl std::fmt::Debug for ImportTree {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ListImport(x) => std::fmt::Debug::fmt(x, f),
			Self::RenameImport(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ImportTree {}
impl AstElement for ImportTree {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ListImport| SyntaxKind::RenameImport) }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::ListImport => AstElement::cast(elem.clone()).map(Self::ListImport),
			SyntaxKind::RenameImport => AstElement::cast(elem.clone()).map(Self::RenameImport),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::ListImport(x) => x.span(),
			Self::RenameImport(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::ListImport(x) => x.inner(),
			Self::RenameImport(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ListImport(SyntaxNode);
impl std::fmt::Debug for ListImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ListImport {}
impl AstElement for ListImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ListImport }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ListImport {
	pub fn path(&self) -> Option<Path> { children(&self.0).nth(0usize) }

	pub fn import_tree_list(&self) -> Option<ImportTreeList> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RenameImport(SyntaxNode);
impl std::fmt::Debug for RenameImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RenameImport {}
impl AstElement for RenameImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RenameImport }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl RenameImport {
	pub fn path(&self) -> Option<Path> { children(&self.0).nth(0usize) }

	pub fn rename(&self) -> Option<Rename> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportTreeList(SyntaxNode);
impl std::fmt::Debug for ImportTreeList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ImportTreeList {}
impl AstElement for ImportTreeList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportTreeList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ImportTreeList {
	pub fn l_brace(&self) -> Option<LBrace> { children(&self.0).nth(0usize) }

	pub fn import_trees(&self) -> impl Iterator<Item = ImportTree> + '_ { children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayType(SyntaxNode);
impl std::fmt::Debug for ArrayType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayType {}
impl AstElement for ArrayType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayType }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ArrayType {
	pub fn l_bracket(&self) -> Option<LBracket> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FnType(SyntaxNode);
impl std::fmt::Debug for FnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FnType {}
impl AstElement for FnType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnType }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl FnType {
	pub fn abi(&self) -> Option<Abi> { children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { children(&self.0).nth(0usize) }

	pub fn params(&self) -> Option<TyParamList> { children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InferType(SyntaxNode);
impl std::fmt::Debug for InferType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InferType {}
impl AstElement for InferType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InferType }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl InferType {
	pub fn underscore(&self) -> Option<Underscore> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathType(SyntaxNode);
impl std::fmt::Debug for PathType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathType {}
impl AstElement for PathType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathType }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl PathType {
	pub fn path(&self) -> Option<Path> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PtrType(SyntaxNode);
impl std::fmt::Debug for PtrType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PtrType {}
impl AstElement for PtrType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PtrType }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl PtrType {
	pub fn star(&self) -> Option<Star> { children(&self.0).nth(0usize) }

	pub fn mut_kw(&self) -> Option<MutKw> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TyParamList(SyntaxNode);
impl std::fmt::Debug for TyParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TyParamList {}
impl AstElement for TyParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TyParamList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl TyParamList {
	pub fn l_paren(&self) -> Option<LParen> { children(&self.0).nth(0usize) }

	pub fn types(&self) -> impl Iterator<Item = Type> + '_ { children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
	Semi(Semi),
	SemiExpr(SemiExpr),
	Expr(Expr),
	Item(Item),
}
impl std::fmt::Debug for Stmt {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::SemiExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Expr(x) => std::fmt::Debug::fmt(x, f),
			Self::Item(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Stmt {}
impl AstElement for Stmt {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Semi| SyntaxKind::SemiExpr | SyntaxKind::Item) || Expr::can_cast(kind)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::SemiExpr => AstElement::cast(elem.clone()).map(Self::SemiExpr),
			SyntaxKind::Item => AstElement::cast(elem.clone()).map(Self::Item),
			SyntaxKind::Semi => AstElement::cast(elem.clone()).map(Self::Semi),
			_ => None,
		}
		.or_else(|| AstElement::cast(elem.clone()).map(Self::Expr))
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::Semi(x) => x.span(),
			Self::SemiExpr(x) => x.span(),
			Self::Expr(x) => x.span(),
			Self::Item(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::Semi(x) => x.inner(),
			Self::SemiExpr(x) => x.inner(),
			Self::Expr(x) => x.inner(),
			Self::Item(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SemiExpr(SyntaxNode);
impl std::fmt::Debug for SemiExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for SemiExpr {}
impl AstElement for SemiExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::SemiExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl SemiExpr {
	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr(SyntaxNode);
impl std::fmt::Debug for ArrayExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayExpr {}
impl AstElement for ArrayExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ArrayExpr {
	pub fn l_bracket(&self) -> Option<LBracket> { children(&self.0).nth(0usize) }

	pub fn array_init(&self) -> Option<ArrayInit> { children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InfixExpr(SyntaxNode);
impl std::fmt::Debug for InfixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InfixExpr {}
impl AstElement for InfixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InfixExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl InfixExpr {
	pub fn lhs(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn op(&self) -> Option<InfixOp> { children(&self.0).nth(0usize) }

	pub fn rhs(&self) -> Option<Expr> { children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr(SyntaxNode);
impl std::fmt::Debug for BreakExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for BreakExpr {}
impl AstElement for BreakExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BreakExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl BreakExpr {
	pub fn break_kw(&self) -> Option<BreakKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CallExpr(SyntaxNode);
impl std::fmt::Debug for CallExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CallExpr {}
impl AstElement for CallExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CallExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl CallExpr {
	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn arg_list(&self) -> Option<ArgList> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CastExpr(SyntaxNode);
impl std::fmt::Debug for CastExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CastExpr {}
impl AstElement for CastExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CastExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl CastExpr {
	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn as_kw(&self) -> Option<AsKw> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr(SyntaxNode);
impl std::fmt::Debug for FieldExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FieldExpr {}
impl AstElement for FieldExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FieldExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl FieldExpr {
	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ForExpr(SyntaxNode);
impl std::fmt::Debug for ForExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ForExpr {}
impl AstElement for ForExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ForExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ForExpr {
	pub fn for_kw(&self) -> Option<ForKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn in_kw(&self) -> Option<InKw> { children(&self.0).nth(0usize) }

	pub fn iter(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IfExpr(SyntaxNode);
impl std::fmt::Debug for IfExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IfExpr {}
impl AstElement for IfExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IfExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl IfExpr {
	pub fn if_kw(&self) -> Option<IfKw> { children(&self.0).nth(0usize) }

	pub fn cond(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Block> { children(&self.0).nth(0usize) }

	pub fn else_kw(&self) -> Option<ElseKw> { children(&self.0).nth(0usize) }

	pub fn else_(&self) -> Option<Expr> { children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode);
impl std::fmt::Debug for IndexExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IndexExpr {}
impl AstElement for IndexExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IndexExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl IndexExpr {
	pub fn base(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn l_bracket(&self) -> Option<LBracket> { children(&self.0).nth(0usize) }

	pub fn index(&self) -> Option<Expr> { children(&self.0).nth(1usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum Literal {
	BoolLit(BoolLit),
	CharLit(CharLit),
	FloatLit(FloatLit),
	IntLit(IntLit),
	StringLit(StringLit),
}
impl std::fmt::Debug for Literal {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::BoolLit(x) => std::fmt::Debug::fmt(x, f),
			Self::CharLit(x) => std::fmt::Debug::fmt(x, f),
			Self::FloatLit(x) => std::fmt::Debug::fmt(x, f),
			Self::IntLit(x) => std::fmt::Debug::fmt(x, f),
			Self::StringLit(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Literal {}
impl AstElement for Literal {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::BoolLit| SyntaxKind::CharLit
			| SyntaxKind::FloatLit
			| SyntaxKind::IntLit
			| SyntaxKind::StringLit)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::BoolLit => AstElement::cast(elem.clone()).map(Self::BoolLit),
			SyntaxKind::CharLit => AstElement::cast(elem.clone()).map(Self::CharLit),
			SyntaxKind::FloatLit => AstElement::cast(elem.clone()).map(Self::FloatLit),
			SyntaxKind::IntLit => AstElement::cast(elem.clone()).map(Self::IntLit),
			SyntaxKind::StringLit => AstElement::cast(elem.clone()).map(Self::StringLit),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::BoolLit(x) => x.span(),
			Self::CharLit(x) => x.span(),
			Self::FloatLit(x) => x.span(),
			Self::IntLit(x) => x.span(),
			Self::StringLit(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::BoolLit(x) => x.inner(),
			Self::CharLit(x) => x.inner(),
			Self::FloatLit(x) => x.inner(),
			Self::IntLit(x) => x.inner(),
			Self::StringLit(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr(SyntaxNode);
impl std::fmt::Debug for LoopExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LoopExpr {}
impl AstElement for LoopExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LoopExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl LoopExpr {
	pub fn loop_kw(&self) -> Option<LoopKw> { children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { children(&self.0).nth(0usize) }

	pub fn while_kw(&self) -> Option<WhileKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr(SyntaxNode);
impl std::fmt::Debug for MatchExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchExpr {}
impl AstElement for MatchExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl MatchExpr {
	pub fn match_kw(&self) -> Option<MatchKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { children(&self.0).nth(0usize) }

	pub fn arms(&self) -> impl Iterator<Item = MatchArm> + '_ { children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode);
impl std::fmt::Debug for ParenExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParenExpr {}
impl AstElement for ParenExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParenExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ParenExpr {
	pub fn l_paren(&self) -> Option<LParen> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn r_paren(&self) -> Option<RParen> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathExpr(SyntaxNode);
impl std::fmt::Debug for PathExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathExpr {}
impl AstElement for PathExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl PathExpr {
	pub fn path(&self) -> Option<Path> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr(SyntaxNode);
impl std::fmt::Debug for PrefixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PrefixExpr {}
impl AstElement for PrefixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PrefixExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl PrefixExpr {
	pub fn op(&self) -> Option<PrefixOp> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RefExpr(SyntaxNode);
impl std::fmt::Debug for RefExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RefExpr {}
impl AstElement for RefExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RefExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl RefExpr {
	pub fn amp(&self) -> Option<Amp> { children(&self.0).nth(0usize) }

	pub fn mut_kw(&self) -> Option<MutKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr(SyntaxNode);
impl std::fmt::Debug for ReturnExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ReturnExpr {}
impl AstElement for ReturnExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ReturnExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ReturnExpr {
	pub fn return_kw(&self) -> Option<ReturnKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr(SyntaxNode);
impl std::fmt::Debug for WhileExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for WhileExpr {}
impl AstElement for WhileExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::WhileExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl WhileExpr {
	pub fn while_kw(&self) -> Option<WhileKw> { children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LetExpr(SyntaxNode);
impl std::fmt::Debug for LetExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LetExpr {}
impl AstElement for LetExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LetExpr }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl LetExpr {
	pub fn let_kw(&self) -> Option<LetKw> { children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum ArrayInit {
	ArrayList(ArrayList),
	ArrayRepeat(ArrayRepeat),
}
impl std::fmt::Debug for ArrayInit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayList(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayRepeat(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ArrayInit {}
impl AstElement for ArrayInit {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ArrayList| SyntaxKind::ArrayRepeat) }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::ArrayList => AstElement::cast(elem.clone()).map(Self::ArrayList),
			SyntaxKind::ArrayRepeat => AstElement::cast(elem.clone()).map(Self::ArrayRepeat),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::ArrayList(x) => x.span(),
			Self::ArrayRepeat(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::ArrayList(x) => x.inner(),
			Self::ArrayRepeat(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayList(SyntaxNode);
impl std::fmt::Debug for ArrayList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayList {}
impl AstElement for ArrayList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ArrayList {
	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayRepeat(SyntaxNode);
impl std::fmt::Debug for ArrayRepeat {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayRepeat {}
impl AstElement for ArrayRepeat {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayRepeat }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ArrayRepeat {
	pub fn expr(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum InfixOp {
	PipePipe(PipePipe),
	AmpAmp(AmpAmp),
	EqEq(EqEq),
	Neq(Neq),
	Leq(Leq),
	Geq(Geq),
	Lt(Lt),
	Gt(Gt),
	Plus(Plus),
	Star(Star),
	Minus(Minus),
	Slash(Slash),
	Percent(Percent),
	Shl(Shl),
	Shr(Shr),
	Caret(Caret),
	Pipe(Pipe),
	Amp(Amp),
	Eq(Eq),
	PlusEq(PlusEq),
	SlashEq(SlashEq),
	StarEq(StarEq),
	PercentEq(PercentEq),
	ShrEq(ShrEq),
	ShlEq(ShlEq),
	MinusEq(MinusEq),
	PipeEq(PipeEq),
	AmpEq(AmpEq),
	CaretEq(CaretEq),
}
impl std::fmt::Debug for InfixOp {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::PipePipe(x) => std::fmt::Debug::fmt(x, f),
			Self::AmpAmp(x) => std::fmt::Debug::fmt(x, f),
			Self::EqEq(x) => std::fmt::Debug::fmt(x, f),
			Self::Neq(x) => std::fmt::Debug::fmt(x, f),
			Self::Leq(x) => std::fmt::Debug::fmt(x, f),
			Self::Geq(x) => std::fmt::Debug::fmt(x, f),
			Self::Lt(x) => std::fmt::Debug::fmt(x, f),
			Self::Gt(x) => std::fmt::Debug::fmt(x, f),
			Self::Plus(x) => std::fmt::Debug::fmt(x, f),
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
			Self::Minus(x) => std::fmt::Debug::fmt(x, f),
			Self::Slash(x) => std::fmt::Debug::fmt(x, f),
			Self::Percent(x) => std::fmt::Debug::fmt(x, f),
			Self::Shl(x) => std::fmt::Debug::fmt(x, f),
			Self::Shr(x) => std::fmt::Debug::fmt(x, f),
			Self::Caret(x) => std::fmt::Debug::fmt(x, f),
			Self::Pipe(x) => std::fmt::Debug::fmt(x, f),
			Self::Amp(x) => std::fmt::Debug::fmt(x, f),
			Self::Eq(x) => std::fmt::Debug::fmt(x, f),
			Self::PlusEq(x) => std::fmt::Debug::fmt(x, f),
			Self::SlashEq(x) => std::fmt::Debug::fmt(x, f),
			Self::StarEq(x) => std::fmt::Debug::fmt(x, f),
			Self::PercentEq(x) => std::fmt::Debug::fmt(x, f),
			Self::ShrEq(x) => std::fmt::Debug::fmt(x, f),
			Self::ShlEq(x) => std::fmt::Debug::fmt(x, f),
			Self::MinusEq(x) => std::fmt::Debug::fmt(x, f),
			Self::PipeEq(x) => std::fmt::Debug::fmt(x, f),
			Self::AmpEq(x) => std::fmt::Debug::fmt(x, f),
			Self::CaretEq(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for InfixOp {}
impl AstElement for InfixOp {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::PipePipe| SyntaxKind::AmpAmp
			| SyntaxKind::EqEq
			| SyntaxKind::Neq
			| SyntaxKind::Leq
			| SyntaxKind::Geq
			| SyntaxKind::Lt
			| SyntaxKind::Gt
			| SyntaxKind::Plus
			| SyntaxKind::Star
			| SyntaxKind::Minus
			| SyntaxKind::Slash
			| SyntaxKind::Percent
			| SyntaxKind::Shl
			| SyntaxKind::Shr
			| SyntaxKind::Caret
			| SyntaxKind::Pipe
			| SyntaxKind::Amp
			| SyntaxKind::Eq
			| SyntaxKind::PlusEq
			| SyntaxKind::SlashEq
			| SyntaxKind::StarEq
			| SyntaxKind::PercentEq
			| SyntaxKind::ShrEq
			| SyntaxKind::ShlEq
			| SyntaxKind::MinusEq
			| SyntaxKind::PipeEq
			| SyntaxKind::AmpEq
			| SyntaxKind::CaretEq)
	}

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::PipePipe => AstElement::cast(elem.clone()).map(Self::PipePipe),
			SyntaxKind::AmpAmp => AstElement::cast(elem.clone()).map(Self::AmpAmp),
			SyntaxKind::EqEq => AstElement::cast(elem.clone()).map(Self::EqEq),
			SyntaxKind::Neq => AstElement::cast(elem.clone()).map(Self::Neq),
			SyntaxKind::Leq => AstElement::cast(elem.clone()).map(Self::Leq),
			SyntaxKind::Geq => AstElement::cast(elem.clone()).map(Self::Geq),
			SyntaxKind::Lt => AstElement::cast(elem.clone()).map(Self::Lt),
			SyntaxKind::Gt => AstElement::cast(elem.clone()).map(Self::Gt),
			SyntaxKind::Plus => AstElement::cast(elem.clone()).map(Self::Plus),
			SyntaxKind::Star => AstElement::cast(elem.clone()).map(Self::Star),
			SyntaxKind::Minus => AstElement::cast(elem.clone()).map(Self::Minus),
			SyntaxKind::Slash => AstElement::cast(elem.clone()).map(Self::Slash),
			SyntaxKind::Percent => AstElement::cast(elem.clone()).map(Self::Percent),
			SyntaxKind::Shl => AstElement::cast(elem.clone()).map(Self::Shl),
			SyntaxKind::Shr => AstElement::cast(elem.clone()).map(Self::Shr),
			SyntaxKind::Caret => AstElement::cast(elem.clone()).map(Self::Caret),
			SyntaxKind::Pipe => AstElement::cast(elem.clone()).map(Self::Pipe),
			SyntaxKind::Amp => AstElement::cast(elem.clone()).map(Self::Amp),
			SyntaxKind::Eq => AstElement::cast(elem.clone()).map(Self::Eq),
			SyntaxKind::PlusEq => AstElement::cast(elem.clone()).map(Self::PlusEq),
			SyntaxKind::SlashEq => AstElement::cast(elem.clone()).map(Self::SlashEq),
			SyntaxKind::StarEq => AstElement::cast(elem.clone()).map(Self::StarEq),
			SyntaxKind::PercentEq => AstElement::cast(elem.clone()).map(Self::PercentEq),
			SyntaxKind::ShrEq => AstElement::cast(elem.clone()).map(Self::ShrEq),
			SyntaxKind::ShlEq => AstElement::cast(elem.clone()).map(Self::ShlEq),
			SyntaxKind::MinusEq => AstElement::cast(elem.clone()).map(Self::MinusEq),
			SyntaxKind::PipeEq => AstElement::cast(elem.clone()).map(Self::PipeEq),
			SyntaxKind::AmpEq => AstElement::cast(elem.clone()).map(Self::AmpEq),
			SyntaxKind::CaretEq => AstElement::cast(elem.clone()).map(Self::CaretEq),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::PipePipe(x) => x.span(),
			Self::AmpAmp(x) => x.span(),
			Self::EqEq(x) => x.span(),
			Self::Neq(x) => x.span(),
			Self::Leq(x) => x.span(),
			Self::Geq(x) => x.span(),
			Self::Lt(x) => x.span(),
			Self::Gt(x) => x.span(),
			Self::Plus(x) => x.span(),
			Self::Star(x) => x.span(),
			Self::Minus(x) => x.span(),
			Self::Slash(x) => x.span(),
			Self::Percent(x) => x.span(),
			Self::Shl(x) => x.span(),
			Self::Shr(x) => x.span(),
			Self::Caret(x) => x.span(),
			Self::Pipe(x) => x.span(),
			Self::Amp(x) => x.span(),
			Self::Eq(x) => x.span(),
			Self::PlusEq(x) => x.span(),
			Self::SlashEq(x) => x.span(),
			Self::StarEq(x) => x.span(),
			Self::PercentEq(x) => x.span(),
			Self::ShrEq(x) => x.span(),
			Self::ShlEq(x) => x.span(),
			Self::MinusEq(x) => x.span(),
			Self::PipeEq(x) => x.span(),
			Self::AmpEq(x) => x.span(),
			Self::CaretEq(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::PipePipe(x) => x.inner(),
			Self::AmpAmp(x) => x.inner(),
			Self::EqEq(x) => x.inner(),
			Self::Neq(x) => x.inner(),
			Self::Leq(x) => x.inner(),
			Self::Geq(x) => x.inner(),
			Self::Lt(x) => x.inner(),
			Self::Gt(x) => x.inner(),
			Self::Plus(x) => x.inner(),
			Self::Star(x) => x.inner(),
			Self::Minus(x) => x.inner(),
			Self::Slash(x) => x.inner(),
			Self::Percent(x) => x.inner(),
			Self::Shl(x) => x.inner(),
			Self::Shr(x) => x.inner(),
			Self::Caret(x) => x.inner(),
			Self::Pipe(x) => x.inner(),
			Self::Amp(x) => x.inner(),
			Self::Eq(x) => x.inner(),
			Self::PlusEq(x) => x.inner(),
			Self::SlashEq(x) => x.inner(),
			Self::StarEq(x) => x.inner(),
			Self::PercentEq(x) => x.inner(),
			Self::ShrEq(x) => x.inner(),
			Self::ShlEq(x) => x.inner(),
			Self::MinusEq(x) => x.inner(),
			Self::PipeEq(x) => x.inner(),
			Self::AmpEq(x) => x.inner(),
			Self::CaretEq(x) => x.inner(),
		}
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArgList(SyntaxNode);
impl std::fmt::Debug for ArgList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArgList {}
impl AstElement for ArgList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArgList }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl ArgList {
	pub fn l_paren(&self) -> Option<LParen> { children(&self.0).nth(0usize) }

	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchArm(SyntaxNode);
impl std::fmt::Debug for MatchArm {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchArm {}
impl AstElement for MatchArm {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchArm }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		let node = elem.into_node()?;
		Self::can_cast(node.kind()).then(|| Self(node))
	}

	fn span(&self) -> FileSpan {
		let range = self.0.text_range();
		FileSpan {
			start: range.start().into(),
			end: range.end().into(),
			relative: (),
		}
	}

	fn inner(self) -> SyntaxElement { self.0.into() }
}
impl MatchArm {
	pub fn value(&self) -> Option<Expr> { children(&self.0).nth(0usize) }

	pub fn fat_arrow(&self) -> Option<FatArrow> { children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Expr> { children(&self.0).nth(1usize) }

	pub fn comma(&self) -> Option<Comma> { children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub enum PrefixOp {
	Minus(Minus),
	Not(Not),
	Star(Star),
}
impl std::fmt::Debug for PrefixOp {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Minus(x) => std::fmt::Debug::fmt(x, f),
			Self::Not(x) => std::fmt::Debug::fmt(x, f),
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for PrefixOp {}
impl AstElement for PrefixOp {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Minus| SyntaxKind::Not | SyntaxKind::Star) }

	fn cast(elem: SyntaxElement) -> Option<Self> {
		match elem.kind() {
			SyntaxKind::Minus => AstElement::cast(elem.clone()).map(Self::Minus),
			SyntaxKind::Not => AstElement::cast(elem.clone()).map(Self::Not),
			SyntaxKind::Star => AstElement::cast(elem.clone()).map(Self::Star),
			_ => None,
		}
	}

	fn span(&self) -> FileSpan {
		match self {
			Self::Minus(x) => x.span(),
			Self::Not(x) => x.span(),
			Self::Star(x) => x.span(),
		}
	}

	fn inner(self) -> SyntaxElement {
		match self {
			Self::Minus(x) => x.inner(),
			Self::Not(x) => x.inner(),
			Self::Star(x) => x.inner(),
		}
	}
}
