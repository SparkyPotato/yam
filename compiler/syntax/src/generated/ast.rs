// This file is generated by build.rs
// Do not edit

use crate::{generated::*, token::*, *};

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Attribute(SyntaxNode);
impl std::fmt::Debug for Attribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Attribute {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Attribute }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Attribute {
	pub fn at(&self) -> Option<At> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn token_tree(&self) -> Option<TokenTree> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Name(SyntaxNode);
impl std::fmt::Debug for Name {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Name {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Name }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Name {
	pub fn ident(&self) -> Option<Ident> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Item(SyntaxNode);
impl std::fmt::Debug for Item {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Item {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Item }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Item {
	pub fn attributes(&self) -> impl Iterator<Item = Attribute> + '_ { node_children(&self.0) }

	pub fn visibility(&self) -> Option<Visibility> { node_children(&self.0).nth(0usize) }

	pub fn item_kind(&self) -> Option<ItemKind> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Visibility(SyntaxNode);
impl std::fmt::Debug for Visibility {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Visibility {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Visibility }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Visibility {
	pub fn pub_kw(&self) -> Option<PubKw> { token_children(&self.0).nth(0usize) }
}

pub enum ItemKind {
	Fn(Fn),
	Struct(Struct),
	Enum(Enum),
	TypeAlias(TypeAlias),
	Static(Static),
	Import(Import),
}
impl std::fmt::Debug for ItemKind {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Fn(x) => std::fmt::Debug::fmt(x, f),
			Self::Struct(x) => std::fmt::Debug::fmt(x, f),
			Self::Enum(x) => std::fmt::Debug::fmt(x, f),
			Self::TypeAlias(x) => std::fmt::Debug::fmt(x, f),
			Self::Static(x) => std::fmt::Debug::fmt(x, f),
			Self::Import(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ItemKind {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Fn| SyntaxKind::Struct
			| SyntaxKind::Enum
			| SyntaxKind::TypeAlias
			| SyntaxKind::Static
			| SyntaxKind::Import)
	}

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::Fn => Fn::cast(node.clone()).map(Self::Fn),
				SyntaxKind::Struct => Struct::cast(node.clone()).map(Self::Struct),
				SyntaxKind::Enum => Enum::cast(node.clone()).map(Self::Enum),
				SyntaxKind::TypeAlias => TypeAlias::cast(node.clone()).map(Self::TypeAlias),
				SyntaxKind::Static => Static::cast(node.clone()).map(Self::Static),
				SyntaxKind::Import => Import::cast(node.clone()).map(Self::Import),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Fn(SyntaxNode);
impl std::fmt::Debug for Fn {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Fn {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Fn }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Fn {
	pub fn abi(&self) -> Option<Abi> { node_children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn param_list(&self) -> Option<ParamList> { node_children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { node_children(&self.0).nth(0usize) }

	pub fn fn_body(&self) -> Option<FnBody> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Struct(SyntaxNode);
impl std::fmt::Debug for Struct {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Struct {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Struct }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Struct {
	pub fn struct_kw(&self) -> Option<StructKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn fields(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Enum(SyntaxNode);
impl std::fmt::Debug for Enum {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Enum {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Enum }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Enum {
	pub fn enum_kw(&self) -> Option<EnumKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn variant_list(&self) -> Option<VariantList> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias(SyntaxNode);
impl std::fmt::Debug for TypeAlias {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TypeAlias {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TypeAlias }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl TypeAlias {
	pub fn type_kw(&self) -> Option<TypeKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Static(SyntaxNode);
impl std::fmt::Debug for Static {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Static {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Static }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Static {
	pub fn static_kw(&self) -> Option<StaticKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Import(SyntaxNode);
impl std::fmt::Debug for Import {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Import {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Import }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Import {
	pub fn import_kw(&self) -> Option<ImportKw> { token_children(&self.0).nth(0usize) }

	pub fn import_tree(&self) -> Option<ImportTree> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Abi(SyntaxNode);
impl std::fmt::Debug for Abi {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Abi {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Abi }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Abi {
	pub fn extern_kw(&self) -> Option<ExternKw> { token_children(&self.0).nth(0usize) }

	pub fn string_lit(&self) -> Option<StringLit> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParamList(SyntaxNode);
impl std::fmt::Debug for ParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParamList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ParamList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn params(&self) -> impl Iterator<Item = Param> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RetTy(SyntaxNode);
impl std::fmt::Debug for RetTy {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RetTy {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RetTy }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl RetTy {
	pub fn arrow(&self) -> Option<Arrow> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

pub enum FnBody {
	Semi(Semi),
	Block(Block),
}
impl std::fmt::Debug for FnBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for FnBody {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Semi| SyntaxKind::Block) }

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::Block => Block::cast(node.clone()).map(Self::Block),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Semi => Semi::cast(tok.clone()).map(Self::Semi),
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Block(SyntaxNode);
impl std::fmt::Debug for Block {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Block {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Block }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Block {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn statements(&self) -> impl Iterator<Item = Stmt> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Param(SyntaxNode);
impl std::fmt::Debug for Param {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Param {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Param }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Param {
	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

pub enum Type {
	ArrayType(ArrayType),
	FnType(FnType),
	InferType(InferType),
	Path(Path),
	PtrType(PtrType),
}
impl std::fmt::Debug for Type {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayType(x) => std::fmt::Debug::fmt(x, f),
			Self::FnType(x) => std::fmt::Debug::fmt(x, f),
			Self::InferType(x) => std::fmt::Debug::fmt(x, f),
			Self::Path(x) => std::fmt::Debug::fmt(x, f),
			Self::PtrType(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Type {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ArrayType| SyntaxKind::FnType
			| SyntaxKind::InferType
			| SyntaxKind::Path
			| SyntaxKind::PtrType)
	}

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayType => ArrayType::cast(node.clone()).map(Self::ArrayType),
				SyntaxKind::FnType => FnType::cast(node.clone()).map(Self::FnType),
				SyntaxKind::InferType => InferType::cast(node.clone()).map(Self::InferType),
				SyntaxKind::Path => Path::cast(node.clone()).map(Self::Path),
				SyntaxKind::PtrType => PtrType::cast(node.clone()).map(Self::PtrType),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct VariantList(SyntaxNode);
impl std::fmt::Debug for VariantList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for VariantList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::VariantList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl VariantList {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn variants(&self) -> impl Iterator<Item = Name> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

pub enum Expr {
	ContinueKw(ContinueKw),
	ArrayExpr(ArrayExpr),
	InfixExpr(InfixExpr),
	Block(Block),
	BreakExpr(BreakExpr),
	CallExpr(CallExpr),
	CastExpr(CastExpr),
	FieldExpr(FieldExpr),
	ForExpr(ForExpr),
	IfExpr(IfExpr),
	IndexExpr(IndexExpr),
	Literal(Literal),
	LoopExpr(LoopExpr),
	MatchExpr(MatchExpr),
	ParenExpr(ParenExpr),
	Path(Path),
	PrefixExpr(PrefixExpr),
	ReturnExpr(ReturnExpr),
	WhileExpr(WhileExpr),
	LetExpr(LetExpr),
}
impl std::fmt::Debug for Expr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ContinueKw(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::InfixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Block(x) => std::fmt::Debug::fmt(x, f),
			Self::BreakExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CallExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::CastExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::FieldExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ForExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IfExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::IndexExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Literal(x) => std::fmt::Debug::fmt(x, f),
			Self::LoopExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::MatchExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ParenExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Path(x) => std::fmt::Debug::fmt(x, f),
			Self::PrefixExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::ReturnExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::WhileExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::LetExpr(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Expr {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::ContinueKw| SyntaxKind::ArrayExpr
			| SyntaxKind::InfixExpr
			| SyntaxKind::Block
			| SyntaxKind::BreakExpr
			| SyntaxKind::CallExpr
			| SyntaxKind::CastExpr
			| SyntaxKind::FieldExpr
			| SyntaxKind::ForExpr
			| SyntaxKind::IfExpr
			| SyntaxKind::IndexExpr
			| SyntaxKind::LoopExpr
			| SyntaxKind::MatchExpr
			| SyntaxKind::ParenExpr
			| SyntaxKind::Path
			| SyntaxKind::PrefixExpr
			| SyntaxKind::ReturnExpr
			| SyntaxKind::WhileExpr
			| SyntaxKind::LetExpr)
			|| Literal::can_cast(kind)
	}

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayExpr => ArrayExpr::cast(node.clone()).map(Self::ArrayExpr),
				SyntaxKind::InfixExpr => InfixExpr::cast(node.clone()).map(Self::InfixExpr),
				SyntaxKind::Block => Block::cast(node.clone()).map(Self::Block),
				SyntaxKind::BreakExpr => BreakExpr::cast(node.clone()).map(Self::BreakExpr),
				SyntaxKind::CallExpr => CallExpr::cast(node.clone()).map(Self::CallExpr),
				SyntaxKind::CastExpr => CastExpr::cast(node.clone()).map(Self::CastExpr),
				SyntaxKind::FieldExpr => FieldExpr::cast(node.clone()).map(Self::FieldExpr),
				SyntaxKind::ForExpr => ForExpr::cast(node.clone()).map(Self::ForExpr),
				SyntaxKind::IfExpr => IfExpr::cast(node.clone()).map(Self::IfExpr),
				SyntaxKind::IndexExpr => IndexExpr::cast(node.clone()).map(Self::IndexExpr),
				SyntaxKind::LoopExpr => LoopExpr::cast(node.clone()).map(Self::LoopExpr),
				SyntaxKind::MatchExpr => MatchExpr::cast(node.clone()).map(Self::MatchExpr),
				SyntaxKind::ParenExpr => ParenExpr::cast(node.clone()).map(Self::ParenExpr),
				SyntaxKind::Path => Path::cast(node.clone()).map(Self::Path),
				SyntaxKind::PrefixExpr => PrefixExpr::cast(node.clone()).map(Self::PrefixExpr),
				SyntaxKind::ReturnExpr => ReturnExpr::cast(node.clone()).map(Self::ReturnExpr),
				SyntaxKind::WhileExpr => WhileExpr::cast(node.clone()).map(Self::WhileExpr),
				SyntaxKind::LetExpr => LetExpr::cast(node.clone()).map(Self::LetExpr),
				_ => None.or_else(|| Literal::cast(node.clone()).map(Self::Literal)),
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::ContinueKw => ContinueKw::cast(tok.clone()).map(Self::ContinueKw),
				_ => None,
			},
		})
	}
}

pub enum ImportTree {
	ListImport(ListImport),
	RenameImport(RenameImport),
}
impl std::fmt::Debug for ImportTree {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ListImport(x) => std::fmt::Debug::fmt(x, f),
			Self::RenameImport(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ImportTree {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ListImport| SyntaxKind::RenameImport) }

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ListImport => ListImport::cast(node.clone()).map(Self::ListImport),
				SyntaxKind::RenameImport => RenameImport::cast(node.clone()).map(Self::RenameImport),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ListImport(SyntaxNode);
impl std::fmt::Debug for ListImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ListImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ListImport }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ListImport {
	pub fn prefix(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn wildcard(&self) -> Option<Wildcard> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct RenameImport(SyntaxNode);
impl std::fmt::Debug for RenameImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for RenameImport {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::RenameImport }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl RenameImport {
	pub fn path(&self) -> Option<Path> { node_children(&self.0).nth(0usize) }

	pub fn rename(&self) -> Option<Rename> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Path(SyntaxNode);
impl std::fmt::Debug for Path {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Path {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Path }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Path {
	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn qualifier(&self) -> impl Iterator<Item = PathSegment> + '_ { node_children(&self.0) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Rename(SyntaxNode);
impl std::fmt::Debug for Rename {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for Rename {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::Rename }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl Rename {
	pub fn as_kw(&self) -> Option<AsKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

pub enum Wildcard {
	Star(Star),
	ImportTreeList(ImportTreeList),
}
impl std::fmt::Debug for Wildcard {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Star(x) => std::fmt::Debug::fmt(x, f),
			Self::ImportTreeList(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Wildcard {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::Star| SyntaxKind::ImportTreeList) }

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ImportTreeList => ImportTreeList::cast(node.clone()).map(Self::ImportTreeList),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Star => Star::cast(tok.clone()).map(Self::Star),
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportTreeList(SyntaxNode);
impl std::fmt::Debug for ImportTreeList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ImportTreeList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ImportTreeList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ImportTreeList {
	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn import_trees(&self) -> impl Iterator<Item = ImportTree> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayType(SyntaxNode);
impl std::fmt::Debug for ArrayType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayType {
	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FnType(SyntaxNode);
impl std::fmt::Debug for FnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FnType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FnType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl FnType {
	pub fn abi(&self) -> Option<Abi> { node_children(&self.0).nth(0usize) }

	pub fn fn_kw(&self) -> Option<FnKw> { token_children(&self.0).nth(0usize) }

	pub fn params(&self) -> Option<TyParamList> { node_children(&self.0).nth(0usize) }

	pub fn ret_ty(&self) -> Option<RetTy> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InferType(SyntaxNode);
impl std::fmt::Debug for InferType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InferType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InferType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl InferType {
	pub fn underscore(&self) -> Option<Underscore> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PtrType(SyntaxNode);
impl std::fmt::Debug for PtrType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PtrType {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PtrType }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PtrType {
	pub fn star(&self) -> Option<Star> { token_children(&self.0).nth(0usize) }

	pub fn ptr_mutability(&self) -> Option<PtrMutability> { node_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TyParamList(SyntaxNode);
impl std::fmt::Debug for TyParamList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for TyParamList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::TyParamList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl TyParamList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn types(&self) -> impl Iterator<Item = Type> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

pub enum PtrMutability {
	ConstKw(ConstKw),
	MutKw(MutKw),
}
impl std::fmt::Debug for PtrMutability {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ConstKw(x) => std::fmt::Debug::fmt(x, f),
			Self::MutKw(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for PtrMutability {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ConstKw| SyntaxKind::MutKw) }

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::ConstKw => ConstKw::cast(tok.clone()).map(Self::ConstKw),
				SyntaxKind::MutKw => MutKw::cast(tok.clone()).map(Self::MutKw),
				_ => None,
			},
		})
	}
}

pub enum Stmt {
	Semi(Semi),
	SemiExpr(SemiExpr),
	Expr(Expr),
	Item(Item),
}
impl std::fmt::Debug for Stmt {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Semi(x) => std::fmt::Debug::fmt(x, f),
			Self::SemiExpr(x) => std::fmt::Debug::fmt(x, f),
			Self::Expr(x) => std::fmt::Debug::fmt(x, f),
			Self::Item(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Stmt {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::Semi| SyntaxKind::SemiExpr | SyntaxKind::Item) || Expr::can_cast(kind)
	}

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::SemiExpr => SemiExpr::cast(node.clone()).map(Self::SemiExpr),
				SyntaxKind::Item => Item::cast(node.clone()).map(Self::Item),
				_ => None.or_else(|| Expr::cast(node.clone()).map(Self::Expr)),
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::Semi => Semi::cast(tok.clone()).map(Self::Semi),
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SemiExpr(SyntaxNode);
impl std::fmt::Debug for SemiExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for SemiExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::SemiExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl SemiExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr(SyntaxNode);
impl std::fmt::Debug for ArrayExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayExpr {
	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn array_init(&self) -> Option<ArrayInit> { node_children(&self.0).nth(0usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct InfixExpr(SyntaxNode);
impl std::fmt::Debug for InfixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for InfixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::InfixExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl InfixExpr {
	pub fn lhs(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn operator(&self) -> Option<Operator> { token_children(&self.0).nth(0usize) }

	pub fn rhs(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr(SyntaxNode);
impl std::fmt::Debug for BreakExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for BreakExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::BreakExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl BreakExpr {
	pub fn break_kw(&self) -> Option<BreakKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CallExpr(SyntaxNode);
impl std::fmt::Debug for CallExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CallExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CallExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl CallExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn arg_list(&self) -> Option<ArgList> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CastExpr(SyntaxNode);
impl std::fmt::Debug for CastExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for CastExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::CastExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl CastExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn as_kw(&self) -> Option<AsKw> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr(SyntaxNode);
impl std::fmt::Debug for FieldExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for FieldExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::FieldExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl FieldExpr {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ForExpr(SyntaxNode);
impl std::fmt::Debug for ForExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ForExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ForExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ForExpr {
	pub fn for_kw(&self) -> Option<ForKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn in_kw(&self) -> Option<InKw> { token_children(&self.0).nth(0usize) }

	pub fn iter(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IfExpr(SyntaxNode);
impl std::fmt::Debug for IfExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IfExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IfExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl IfExpr {
	pub fn if_kw(&self) -> Option<IfKw> { token_children(&self.0).nth(0usize) }

	pub fn cond(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }

	pub fn else_kw(&self) -> Option<ElseKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode);
impl std::fmt::Debug for IndexExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for IndexExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::IndexExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl IndexExpr {
	pub fn base(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn l_bracket(&self) -> Option<LBracket> { token_children(&self.0).nth(0usize) }

	pub fn index(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }

	pub fn r_bracket(&self) -> Option<RBracket> { token_children(&self.0).nth(0usize) }
}

pub enum Literal {
	BoolLit(BoolLit),
	CharLit(CharLit),
	FloatLit(FloatLit),
	IntLit(IntLit),
	StringLit(StringLit),
}
impl std::fmt::Debug for Literal {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::BoolLit(x) => std::fmt::Debug::fmt(x, f),
			Self::CharLit(x) => std::fmt::Debug::fmt(x, f),
			Self::FloatLit(x) => std::fmt::Debug::fmt(x, f),
			Self::IntLit(x) => std::fmt::Debug::fmt(x, f),
			Self::StringLit(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for Literal {
	fn can_cast(kind: SyntaxKind) -> bool {
		matches!(kind, |SyntaxKind::BoolLit| SyntaxKind::CharLit
			| SyntaxKind::FloatLit
			| SyntaxKind::IntLit
			| SyntaxKind::StringLit)
	}

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				SyntaxKind::BoolLit => BoolLit::cast(tok.clone()).map(Self::BoolLit),
				SyntaxKind::CharLit => CharLit::cast(tok.clone()).map(Self::CharLit),
				SyntaxKind::FloatLit => FloatLit::cast(tok.clone()).map(Self::FloatLit),
				SyntaxKind::IntLit => IntLit::cast(tok.clone()).map(Self::IntLit),
				SyntaxKind::StringLit => StringLit::cast(tok.clone()).map(Self::StringLit),
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr(SyntaxNode);
impl std::fmt::Debug for LoopExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LoopExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LoopExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl LoopExpr {
	pub fn loop_kw(&self) -> Option<LoopKw> { token_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }

	pub fn while_kw(&self) -> Option<WhileKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr(SyntaxNode);
impl std::fmt::Debug for MatchExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl MatchExpr {
	pub fn match_kw(&self) -> Option<MatchKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn l_brace(&self) -> Option<LBrace> { token_children(&self.0).nth(0usize) }

	pub fn arms(&self) -> impl Iterator<Item = MatchArm> + '_ { node_children(&self.0) }

	pub fn r_brace(&self) -> Option<RBrace> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode);
impl std::fmt::Debug for ParenExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ParenExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ParenExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ParenExpr {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr(SyntaxNode);
impl std::fmt::Debug for PrefixExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PrefixExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PrefixExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PrefixExpr {
	pub fn operator(&self) -> Option<Operator> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr(SyntaxNode);
impl std::fmt::Debug for ReturnExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ReturnExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ReturnExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ReturnExpr {
	pub fn return_kw(&self) -> Option<ReturnKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr(SyntaxNode);
impl std::fmt::Debug for WhileExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for WhileExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::WhileExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl WhileExpr {
	pub fn while_kw(&self) -> Option<WhileKw> { token_children(&self.0).nth(0usize) }

	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn body(&self) -> Option<Block> { node_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct LetExpr(SyntaxNode);
impl std::fmt::Debug for LetExpr {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for LetExpr {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::LetExpr }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl LetExpr {
	pub fn let_kw(&self) -> Option<LetKw> { token_children(&self.0).nth(0usize) }

	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn colon(&self) -> Option<Colon> { token_children(&self.0).nth(0usize) }

	pub fn type_(&self) -> Option<Type> { node_children(&self.0).nth(0usize) }

	pub fn eq(&self) -> Option<Eq> { token_children(&self.0).nth(0usize) }

	pub fn init(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }
}

pub enum ArrayInit {
	ArrayList(ArrayList),
	ArrayRepeat(ArrayRepeat),
}
impl std::fmt::Debug for ArrayInit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::ArrayList(x) => std::fmt::Debug::fmt(x, f),
			Self::ArrayRepeat(x) => std::fmt::Debug::fmt(x, f),
		}
	}
}
impl AstNode for ArrayInit {
	fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, |SyntaxKind::ArrayList| SyntaxKind::ArrayRepeat) }

	fn cast(node: SyntaxNode) -> Option<Self> {
		node.children_with_tokens().find_map(|x| match x {
			SyntaxElementRef::Node(node) => match node.kind() {
				SyntaxKind::ArrayList => ArrayList::cast(node.clone()).map(Self::ArrayList),
				SyntaxKind::ArrayRepeat => ArrayRepeat::cast(node.clone()).map(Self::ArrayRepeat),
				_ => None,
			},
			SyntaxElementRef::Token(tok) => match tok.kind() {
				_ => None,
			},
		})
	}
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayList(SyntaxNode);
impl std::fmt::Debug for ArrayList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayList {
	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArrayRepeat(SyntaxNode);
impl std::fmt::Debug for ArrayRepeat {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArrayRepeat {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArrayRepeat }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArrayRepeat {
	pub fn expr(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn semi(&self) -> Option<Semi> { token_children(&self.0).nth(0usize) }

	pub fn len(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ArgList(SyntaxNode);
impl std::fmt::Debug for ArgList {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for ArgList {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::ArgList }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl ArgList {
	pub fn l_paren(&self) -> Option<LParen> { token_children(&self.0).nth(0usize) }

	pub fn exprs(&self) -> impl Iterator<Item = Expr> + '_ { node_children(&self.0) }

	pub fn r_paren(&self) -> Option<RParen> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct MatchArm(SyntaxNode);
impl std::fmt::Debug for MatchArm {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for MatchArm {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::MatchArm }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl MatchArm {
	pub fn value(&self) -> Option<Expr> { node_children(&self.0).nth(0usize) }

	pub fn fat_arrow(&self) -> Option<FatArrow> { token_children(&self.0).nth(0usize) }

	pub fn then(&self) -> Option<Expr> { node_children(&self.0).nth(1usize) }

	pub fn comma(&self) -> Option<Comma> { token_children(&self.0).nth(0usize) }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct PathSegment(SyntaxNode);
impl std::fmt::Debug for PathSegment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Debug::fmt(&self.0, f) }
}
impl AstNode for PathSegment {
	fn can_cast(kind: SyntaxKind) -> bool { kind == SyntaxKind::PathSegment }

	fn cast(node: SyntaxNode) -> Option<Self> {
		if Self::can_cast(node.kind()) {
			Some(Self(node))
		} else {
			None
		}
	}
}
impl PathSegment {
	pub fn name(&self) -> Option<Name> { node_children(&self.0).nth(0usize) }

	pub fn dot(&self) -> Option<Dot> { token_children(&self.0).nth(0usize) }
}
