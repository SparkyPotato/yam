//! ### Storage routing
//!
//! The database has two tiers of storing data:
//! - The database itself, storing storage structs.
//! - Storage structs, which store the actual type storages.
//!
//! This allows for multi-crate compilation, where each crate exposes a storage struct, with only the main driver crate
//! using the database.

use std::any::TypeId;

use rustc_hash::FxHashMap;

use crate::{internal::Storable, Db};

/// A type-erased route through the database storage.
/// Uniquely identifies the storage for a particular [`Tracked`](crate::Tracked) type.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Route {
	/// The index of the storage struct in the database.
	/// A storage of `0` is reserved for fake queries generated by [`crate::Db::set_input`].
	pub storage: u16,
	/// The index of the type storage in the storage struct.
	pub index: u16,
}

impl Route {
	pub(crate) fn input() -> Self { Self { storage: 0, index: 0 } }
}

/// A static table that maps [`TypeId`]s to [`Route`]s, generated at database initialization.
/// This is required because `TypeId`s are not guaranteed to be stable across compilations, while `Route`s are.
#[derive(Default)]
pub struct RoutingTable {
	routes: FxHashMap<TypeId, Route>,
	type_names: FxHashMap<Route, &'static str>,
	pushables: Vec<Route>,
}

impl RoutingTable {
	pub fn route<T: Storable>(&self) -> Route {
		match self.routes.get(&TypeId::of::<T>()) {
			Some(route) => *route,
			None => panic!("Database does not contain `{}`", std::any::type_name::<T>()),
		}
	}

	pub fn name(&self, route: Route) -> &str { self.type_names.get(&route).unwrap() }

	pub fn pushables(&self) -> &[Route] { &self.pushables }

	pub fn generate_for_db<T: Db>() -> Self {
		let mut builder = RoutingTableBuilder::default();
		T::init_routing(&mut builder);
		builder.finish()
	}
}

#[derive(Default)]
pub struct RoutingTableBuilder {
	routes: FxHashMap<TypeId, Route>,
	type_names: FxHashMap<Route, &'static str>,
	pushables: Vec<Route>,
}

impl RoutingTableBuilder {
	pub fn start_route(&mut self, storage: u16) -> RouteBuilder {
		RouteBuilder {
			routes: &mut self.routes,
			type_names: &mut self.type_names,
			pushables: &mut self.pushables,
			storage,
		}
	}

	pub fn finish(self) -> RoutingTable {
		RoutingTable {
			routes: self.routes,
			type_names: self.type_names,
			pushables: self.pushables,
		}
	}
}

pub struct RouteBuilder<'a> {
	routes: &'a mut FxHashMap<TypeId, Route>,
	type_names: &'a mut FxHashMap<Route, &'static str>,
	pushables: &'a mut Vec<Route>,
	storage: u16,
}

impl RouteBuilder<'_> {
	pub fn add<T: Storable>(&mut self, index: u16) {
		let route = Route {
			storage: self.storage,
			index,
		};
		let id = TypeId::of::<T>();

		if T::IS_PUSHABLE {
			self.pushables.push(route);
		}

		if self.routes.insert(id, route).is_some() {
			panic!("Duplicate route for type `{}`", std::any::type_name::<T>());
		}
		self.type_names.insert(route, std::any::type_name::<T>());
	}
}
